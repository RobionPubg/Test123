#include "Includes.h"
#include "Tools.h"
#include "fake_dlfcn.h"
#include "Vector3.hpp"
#include "imgui/imgui.h"
#include "imgui/backends/imgui_impl_android.h"
#include "imgui/backends/imgui_impl_opengl3.h"
#include "StrEnc.h"
#include "plthook.h"
#include "Items.h"
#include "fontch.h"
#include "obfuscate.h"
#include "KittyMemory/MemoryPatch.h"
#include "json.hpp"
#include "Rect.h"
#include "Iconcpp.h"
#include "ImguiPP.cpp"
#include "Menu.h"
#include "Font.h"
#include "Font.h"
#include "Icon.h"
#include "ImguiPP.h"
#include "Spoof.h"
#include "SDK.hpp"
#include <list>
#include <vector>
#include <cstring>
#include <pthread.h>
#include <thread>
#include <cstring>
#include <jni.h>
#include <unistd.h>
#include <fstream>
#include <iostream>
#include <dlfcn.h>
#include "Vector2.hpp"
#include "Macros.h"
#include "font1.h"
using json = nlohmann::json;
#define SLEEP_TIME 1000LL / 60LL
#include "SDK.hpp"
using namespace SDK;
#include <curl/curl.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include "base64/base64.h"
bool HIDEESP = true;
char extra[32];
static bool IgnoreBot = false;
#define IM_PI                   3.14159265358979323846f
#define RAD2DEG(x) ((float)(x) * (float)(180.f / IM_PI))
#define DEG2RAD(x) ((float)(x) * (float)(IM_PI / 180.f))
#define W2S(w, s) UGameplayStatics::ProjectWorldToScreen(localController, w, true, s)

void RotateTriangle(std::array<Vector3, 3> & points, float rotation) {
    const auto points_center = (points.at(0) + points.at(1) +  points.at(2)) / 3;
    for (auto & point : points) {
        point = point - points_center;
        const auto temp_x = point.X;
        const auto temp_y = point.Y;
        const auto theta = DEG2RAD(rotation);
        const auto c = cosf(theta);
        const auto s = sinf(theta);
        point.X = temp_x * c - temp_y * s;
        point.Y = temp_x * s + temp_y * c;
        point = point + points_center;
    }
}
bool WriteAddr(void *addr, void *buffer, size_t length) {
    unsigned long page_size = sysconf(_SC_PAGESIZE);
    unsigned long size = page_size * sizeof(uintptr_t);
    return mprotect((void *) ((uintptr_t) addr - ((uintptr_t) addr % page_size) - page_size), (size_t) size, PROT_EXEC | PROT_READ | PROT_WRITE) == 0 && memcpy(addr, buffer, length) != 0;
}


#define DefineHook(RET, NAME, ARGS) \
	RET(*Orig_##NAME)               \
	ARGS;                           \
	RET Hook_##NAME ARGS

template<typename T>
void Write(uintptr_t addr, T value) {
    WriteAddr((void *) addr, &value, sizeof(T));
}


using json = nlohmann::json;
using namespace SDK;
#include <curl/curl.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>

//bypass 1st Func Start
#define MEMORY(lib, offset, hex) patchOffset(OBFUSCATE(lib), string2Offset(OBFUSCATE(offset)), OBFUSCATE(hex), true)
#if defined(__aarch64__)
std::vector<uint64_t> offsetVector;
#else

#endif


#define targetLibName OBFUSCATE("libUE4.so")  /// here you can ad your lib name
#define targetLibName OBFUSCATE("libanort.so")
#define targetLibName OBFUSCATE("libanogs.so")
// ======================================================================== //

// ======================================================================== //
float FOVSize = 0;
bool initImGui = false;
bool pink = false;
bool rectangle = false;
bool border = false;
bool flyToggle = false;
bool show_Color1 = false;
bool show_another_info = false;
bool Bypass2 = true;
bool Bypass3 = true;
bool Bypass4 = true;

int screenWidth = -1, glWidth, screenHeight = -1, glHeight;
ImFont* Arabic;
time_t rng = 0;
float density = -1;
bool bValid = false;
#define SLEEP_TIME 1000LL / 120LL
uintptr_t tersafe;

static int a = 0;
std::string expiretime = "";
json mItemData;
json items_data;
std::string g_Token, g_Auth;
static std::string EXP = "00:00:00:00:00:00:00";
std::string name ="";
std::string device = "";
std::string status = "";
std::string floating ="";

std::string KeySlot = "";
std::string FlotingText = "";
std::string expiredDate = "";

//std::string expiredDate = "";

// ======================================================================== //

// ======================================================================== //
typedef void (*ImGuiDemoMarkerCallback)(const char* file, int line, const char* section, void* user_data);
extern ImGuiDemoMarkerCallback  GImGuiDemoMarkerCallback;
extern void* GImGuiDemoMarkerCallbackUserData;
ImGuiDemoMarkerCallback         GImGuiDemoMarkerCallback = NULL;
void* GImGuiDemoMarkerCallbackUserData = NULL;
#define IMGUI_DEMO_MARKER(section)  do { if (GImGuiDemoMarkerCallback != NULL) GImGuiDemoMarkerCallback(__FILE__, __LINE__, section, GImGuiDemoMarkerCallbackUserData); } while (0)
// ======================================================================== //


static int xsuit = 0;
static int skinm4 = 0;
static int skinakm = 0;
static int skinscar = 0;
static int skinm7 = 0;
static int skinuzi = 0;
static int skinump45 = 0;
static int skinvector = 0;
static int skinbizon = 0;
static int skingroza = 0;
static int skinkar = 0;
static int skinm24 = 0;
static int skinawm = 0;
static int skindp28 = 0;
static int skinqbz = 0;
static int skinm16a4 = 0;
static int skinm249 = 0;
static int skinmini14 = 0;
static int skinslr = 0;
static int skinsks = 0;
static int skinpan = 0;
static int skins1897 = 0;
static int skinvss = 0;
static int skins12k = 0;
static int skinaug = 0;
static int skinmk14 = 0;



enum EEsp {
  eno = 0,
  Top = 1,
  Mid = 2,
  Buttom = 3,
  
};

enum EEspp {
  no = 0,
  Up = 1,
  Middle = 2,
  Low = 3,
  
};

enum Em416 {
    nom4 = 0,
    m4gc = 1,
    m4fool = 2,
    m4lizard = 3,

};
enum EAim {
  Distance = 0,
  Croshhair = 1
};

enum EAimTarget {
    Head = 0,
    Chest = 1
};

enum EAimTrigger {
    None = 4,
    Shooting = 1,
    Scoping = 2,
    Both = 3,
    Any = 0,
};
std::map<int, bool> Items;
std::map<int, float *> ItemColors;

struct sConfig {
	bool Bypass;
	bool ReportBlock;	
	bool Bypass2;
	bool Bypass3;
	bool Bypass4;
	float Meter;
	float Recc;
    bool EnemyWeapon;
	float Line;
	float Skeleton;
	float Skill;
    bool HitEffect;
	bool Small;
	bool Predection;
    struct sESPMenu {
    bool Meter;
		bool Alert;
        bool bypass;
        bool Line;
        bool Box;
        bool Dbox;
		bool Weapon;
		bool AutoFire;
		bool Below;
		bool HitEffect;
		bool Mid;
        bool Skeleton;
        bool Health;
        bool ShowKnockedHealth;
        bool Name;
        bool Distance;
        bool TeamID;
        bool VehicleHP;
		bool VehicleFuel;
		bool Vehicle;
        bool NoBot;
        bool LootBox;
        bool Grenade;
        bool Radar;
        float Recc;
        bool Predection;
    };
    sESPMenu ESPMenu;

    struct sPlayerESP {
        bool Bypass;
        bool ECount;
        bool Line;
        bool Box;
        bool Skeleton;
        bool Health;
        bool ShowKnockedHealth;
        bool Name;
        bool Distance;
        int DistanceMax;
        bool TeamID;
        bool LootBox;
        bool Grenade;
        bool Weapon;
        bool Alert;
        bool NoBot;
        bool radar;
        bool sfps;
    };
    sPlayerESP PlayerESP{0};
    
    struct sVehicleESP {    
        bool ShowVehicle;
        bool ShowDistance;
    };
    sVehicleESP VehicleESP{0};
    
    struct smemory {
        bool Recoil;
        bool Shake;
        bool Small;
        bool Instant;
        bool HitEffect;
        bool ipad;
        bool autofire;
    };    
    smemory memory{0};
    
    struct sWeaponAim {
        bool Bypass;
        bool Enable;
        bool AimBot;
		float Cross;
		bool Fovedit;
	    float Recc;
	    bool SafeRec;
	    float Rec;
		EAim Aim;
        EAimTarget Target;
        EAimTrigger Trigger;
        bool IgnoreKnocked;
        bool IgnoreBot;
        bool VisCheck;
        bool Predection;
    };
    sWeaponAim AimBot{0};
    sWeaponAim BulletTracking{0};
    
    	struct MemoryHack {
        bool Aimbot;
        bool CarFly;
        bool FixStuck;
        bool FlashV2;
        bool FlashV5;
        bool FlashV1;
        bool KnockSpeed;
        bool LessRecoil;
        bool MagicBullet;
		bool godview;
		bool up;
		bool down;
		bool front;
		bool BEHIND;
		bool left;
		bool right;
        bool RainBowXkill;
        bool RemoveFog;
		bool Bypass;
		bool bypass;
        bool SitFly;
        bool StaticCross;
        bool SlowMotion;
        bool WallLoot;
        bool Xkill;
        bool killmessage;

        bool mc;
        bool xk;
        bool fs;
        bool ms;
        bool m416;
        bool m4sel;
        bool akm;
		bool carteleport;
		bool cartrack;
    };
	 MemoryHack MemoryHacks{0};
	 
struct sColorsESP {
        float *Line;
        float *Box;
        float *Name;
        float *Distance;
        float *TeamID;
        float *Skeleton;
        float *SkeletonVisible;
        float *Vehicle;
    	float *Menucolour;
		float *Fov;
	//	float *Fova;
    };
    sColorsESP ColorsESP{0};
    
	struct sOTHER {
        bool FPS;
        bool HIDEESP;
        bool EXPIRYTIME;
    };
    sOTHER OTHER{0};
};
sConfig Config{0};

#define CREATE_COLOR(r, g, b, a) new float[4] {(float)r, (float)g, (float)b, (float)a};

// ======🅼🅰🅳🅴 🅱🆈  UBAYDULLA====================================== //

uintptr_t anort;
uintptr_t UE4;
uintptr_t anogs;
uintptr_t g_UE4;
uintptr_t TDataMaster;
uintptr_t ANOGS;
uintptr_t tgpa;
uintptr_t gcloud;
uintptr_t Anogs;
uintptr_t AimBullet_Offset;
uintptr_t GWorld_Offset, GUObjectArray_Offset, BulletTracking_Offset;
android_app *g_App = 0;
ASTExtraPlayerCharacter *g_LocalPlayer = 0;
ASTExtraPlayerController *g_LocalController = 0;

#define GEngine_Offset 0x859932c
#define GNames_Offset 0x4399758
#define GUObject_Offset 0x8c0d7f0
#define GNativeAndroidApp_Offset 0x88930ec
#define GetActorArray 0x5c62640
#define ShortEvent_Offset 165 //BT
#define Actors_Offset 0x70


struct sRegion {
    uintptr_t start, end;
};

std::vector<sRegion> trapRegions;
/*bool isInsideFOV(int x, int y) {
    if (!Config.AimBot.FOV)
        return true;

    int circle_x = screenWidth / 3.0f;
    int circle_y = screenHeight / 3.0f;
    int rad = Config.AimBot.Cross;
    return (x - circle_x) * (x - circle_x) + (y - circle_y) * (y - circle_y) <= rad * rad;
}*/
bool isObjectInvalid(UObject *obj) {
    if (!Tools::IsPtrValid(obj)) {
        return true;
    }

    if (!Tools::IsPtrValid(obj->ClassPrivate)) {
        return true;
    }

    if (obj->InternalIndex <= 0) {
        return true;
    }

    if (obj->NamePrivate.ComparisonIndex <= 0) {
        return true;
    }

    if ((uintptr_t)(obj) % sizeof(uintptr_t) != 0x0 && (uintptr_t)(obj) % sizeof(uintptr_t) != 0x4) {
        return true;
    }

    if (std::any_of(trapRegions.begin(), trapRegions.end(), [obj](sRegion region) { return ((uintptr_t) obj) >= region.start && ((uintptr_t) obj) <= region.end; }) ||
        std::any_of(trapRegions.begin(), trapRegions.end(), [obj](sRegion region) { return ((uintptr_t) obj->ClassPrivate) >= region.start && ((uintptr_t) obj->ClassPrivate) <= region.end; })) {
        return true;
    }

    return false;
}

static UEngine *GEngine = 0;
UWorld *GetWorld() {
    while (!GEngine) {
        GEngine = UObject::FindObject<UEngine>("UAEGameEngine Transient.UAEGameEngine_1"); // Auto 
        sleep(1);
    }
    if (GEngine) {
        auto ViewPort = GEngine->GameViewport;

        if (ViewPort) {
   //return {};
            return ViewPort->World;
        }
    }
    return 0;
}
TNameEntryArray *GetGNames() {
    return ((TNameEntryArray *(*)()) (g_UE4 + GNames_Offset))();
}

std::vector<AActor *> getActors() {
    auto World = GetWorld();
    if (!World)
        return std::vector<AActor *>();
 
    auto PersistentLevel = World->PersistentLevel;
    if (!PersistentLevel)
        return std::vector<AActor *>();
 
    struct GovnoArray {
        uintptr_t base;
        int32_t count;
        int32_t max;
    };
    static thread_local GovnoArray Actors{};
 
    Actors = *(((GovnoArray*(*)(uintptr_t))(g_UE4 + GetActorArray))(reinterpret_cast<uintptr_t>(PersistentLevel)));
 
    if (Actors.count <= 0) {
        return {};
    }
 
    std::vector<AActor *> actors;
    for (int i = 0; i < Actors.count; i++) {
        auto Actor = *(uintptr_t *) (Actors.base + (i * sizeof(uintptr_t)));
        if (Actor) {
            actors.push_back(reinterpret_cast<AActor *const>(Actor));
        }
    }
    return actors;
}

std::string getObjectPath(UObject *Object) {
    std::string s;
    for (auto super = Object->ClassPrivate; super; super = (UClass *) super->SuperStruct) {
        if (!s.empty())
            s += ".";
        s += super->NamePrivate.GetName();
    }
    return s;
}
/*

void VectorAnglesRadar(Vector3 & forward, FVector & angles) {
    if (forward.X == 0.f && forward.Y == 0.f) {
        angles.X = forward.Z > 0.f ? -90.f : 90.f;
        angles.Y = 0.f;
    } else {
        angles.X = RAD2DEG(atan2(-forward.Z, forward.Magnitude(forward)));
        angles.Y = RAD2DEG(atan2(forward.Y, forward.X));
    }
    angles.Z = 0.f;
}
*/
// =======🅼🅰🅳🅴 🅱🆈  🅼🅾🅳 🆇======================= //
int32_t ToColor(float *col) {
    return ImGui::ColorConvertFloat4ToU32(*(ImVec4 *) (col));
}
//==//
FRotator ToRotator(FVector local, FVector target) {
    FVector rotation = UKismetMathLibrary::Subtract_VectorVector(local, target);
    float hyp = sqrt(rotation.X * rotation.X + rotation.Y * rotation.Y);
    FRotator newViewAngle = {0};
    newViewAngle.Pitch = -atan(rotation.Z / hyp) * (180.f / (float) 3.14159265358979323846);
    newViewAngle.Yaw = atan(rotation.Y / rotation.X) * (180.f / (float) 3.14159265358979323846);
    newViewAngle.Roll = (float) 0.f;
    if (rotation.X >= 0.f)
        newViewAngle.Yaw += 180.0f;
    return newViewAngle;
}
//========🅼🅰🅳🅴 🅱🆈  UBAYDULLA===================//
#define W2S(w, s) UGameplayStatics::ProjectWorldToScreen(localController, w, true, s)
//===========AIMBOTDEFINE======////
bool isInsideFOV(int x, int y) {
    if (!FOVSize)
        return true;

    int circle_x = glWidth / 2;
    int circle_y = glHeight / 2;
    int rad = FOVSize;
    return (x - circle_x) * (x - circle_x) + (y - circle_y) * (y - circle_y) <= rad * rad;
}


auto GetTargetForAimBot() {
   ASTExtraPlayerCharacter *result = 0;
    float max = std::numeric_limits<float>::infinity();
    auto Actors = getActors();
    auto localPlayer = g_LocalPlayer;
    auto localController = g_LocalController;
    if (localPlayer)
    {
        for (int i = 0; i < Actors.size(); i++) {
                    auto Actor = Actors[i];
            if (isObjectInvalid(Actor))
                continue;
            if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass()))
            {
                auto Player = (ASTExtraPlayerCharacter *)Actor;
                auto Target = (ASTExtraPlayerCharacter *) Actor;

                float dist = localPlayer->GetDistanceTo(Target) / 100.0f;    
                if (dist > Config.Meter)
                    continue;
                        
                if (Player->PlayerKey == localPlayer->PlayerKey)
                    continue;
                if (Player->TeamID == localPlayer->TeamID)
                    continue;
                if (Player->bDead)
                    continue;
                    
                    
                if (Config.AimBot.IgnoreKnocked) {
                    if (Player->Health == 0.0f)
                        continue;
                }

                if (Config.AimBot.VisCheck) {
                    if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                        continue;
                }
                if (Config.AimBot.IgnoreBot) {
                    if (Player->bIsAI)
                        continue;
                }

                        auto Root = Player->GetBonePos("Root", {});
                auto Head = Player->GetBonePos("Head", {});
                FVector2D RootSc, HeadSc;
                if (W2S(Root, &RootSc) && W2S(Head, &HeadSc))
                {
                    float height = abs(HeadSc.Y - RootSc.Y);
                    float width = height * 0.65f;

                    FVector middlePoint = {HeadSc.X + (width / 2), HeadSc.Y + (height / 2), 0};
                    if ((middlePoint.X >= 0 && middlePoint.X <= glWidth) && (middlePoint.Y >= 0 && middlePoint.Y <= glHeight))
                    {
                        FVector2D v2Middle = FVector2D((float)(glWidth / 2), (float)(glHeight / 2));
                        FVector2D v2Loc = FVector2D(middlePoint.X, middlePoint.Y);
                        

                        
                        
                                if(isInsideFOV((int)middlePoint.X, (int)middlePoint.Y)) {

                                float dist = FVector2D::Distance(v2Middle, v2Loc);

                                if (dist < max) {
                                    max = dist;
                                    result = Player;
                                }
                              
                            }
                        }
                  }  
                
            }
        }
    }

    return result;
}
void VectorAnglesRadar(Vector3 & forward, FVector & angles) {
    if (forward.X == 0.f && forward.Y == 0.f) {
        angles.X = forward.Z > 0.f ? -90.f : 90.f;
        angles.Y = 0.f;
    } else {
        angles.X = RAD2DEG(atan2(-forward.Z, forward.Magnitude(forward)));
        angles.Y = RAD2DEG(atan2(forward.Y, forward.X));
    }
    angles.Z = 0.f;
}

//=====BukketTrack======//

auto GetTargetForBT() {
    ASTExtraPlayerCharacter *result = 0;
    float max = std::numeric_limits<float>::infinity();

    auto GWorld = GetWorld();
    if (GWorld) {
        ULevel *PersistentLevel = GWorld->PersistentLevel;
        if (PersistentLevel) {
            TArray<AActor *> Actors = *(TArray<AActor *> *) ((uintptr_t) PersistentLevel +
                                                             Actors_Offset);


            auto localPlayer = g_LocalPlayer;
            auto localController = g_LocalController;

            if (localPlayer) {
                for (int i = 0; i < Actors.Num(); i++) {
                    auto Actor = Actors[i];
                    if (isObjectInvalid(Actor))
                        continue;

                    if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass())) {
                        auto Player = (ASTExtraPlayerCharacter *) Actor;

                        if (Player->PlayerKey == localPlayer->PlayerKey)
                            continue;

                        if (Player->TeamID == localPlayer->TeamID)
                            continue;

                        if (Player->bDead)
                            continue;

                        if (Config.BulletTracking.IgnoreKnocked) {
                            if (Player->Health == 0.0f)
                                continue;
                        }

                        if (Config.BulletTracking.VisCheck) {
                            if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                                continue;
                        }

                        if (Config.BulletTracking.IgnoreBot) {
                            if (Player->bIsAI)
                                continue;
                        }
                        
                        if (IgnoreBot) {
                    if (Player->bIsAI)
                        continue;
                }

                        auto Root = Player->GetBonePos("Root", {});
                        auto Head = Player->GetBonePos("Head", {});

                        FVector2D RootSc, HeadSc;
                        if (W2S(Root, &RootSc) && W2S(Head, &HeadSc)) {
                            float height = abs(HeadSc.Y - RootSc.Y);
                            float width = height * 0.65f;

                            FVector middlePoint = {HeadSc.X + (width / 2), HeadSc.Y + (height / 2),
                                                   0};
                            if ((middlePoint.X >= 0 && middlePoint.X <= glWidth) &&
                                (middlePoint.Y >= 0 && middlePoint.Y <= glHeight)) {
                                FVector2D v2Middle = FVector2D((float) (glWidth / 2),
                                                               (float) (glHeight / 2));
                                FVector2D v2Loc = FVector2D(middlePoint.X, middlePoint.Y);

                                float dist = FVector2D::Distance(v2Middle, v2Loc);

                                if (dist < max) {
                                    max = dist;
                                    result = Player;
                                }
                            }
                        }
                    }
                }
            }

            return result;
        }
    }
}


auto GetTargetByPussy() {
    ASTExtraPlayerCharacter *result = 0;
    float max = std::numeric_limits<float>::infinity();
     auto Actors = getActors();
     
    auto localPlayer = g_LocalPlayer;
    auto localController = g_LocalController;
    FVector ViewPosY{0, 0, 0};
    if (localPlayer) {                   
       ViewPosY = localPlayer->GetBonePos("Head", {});
       ViewPosY.Z += 10.f;
    }  
    if (localPlayer) {
        for (int i = 0; i < Actors.size(); i++) {
            auto Actor = Actors[i];
            if (isObjectInvalid(Actor))
                continue;

            if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass())) {
                auto Player = (ASTExtraPlayerCharacter *) Actor;

                if (Player->PlayerKey == localPlayer->PlayerKey)
                    continue;

                if (Player->TeamID == localPlayer->TeamID)
                    continue;

                if (Player->bDead)
                    continue;

               /* if (Config.SilentAim.IgnoreKnocked) {
                    if (Player->Health == 0.0f)
                        continue;
                }
        
                if (Config.SilentAim.IgnoreBots) {
                    if (Player->bIsAI)
                        continue;
                }*/
                   if (IgnoreBot) {
                    if (Player->bIsAI)
                        continue;
                }
                 
                    if (!localController->LineOfSightTo(Player, ViewPosY, true))
                              continue;
      
                        float dist = g_LocalPlayer->GetDistanceTo(Player);
                             if (dist < max) {
                                 max = dist;
                              result = Player;
                        }
                    }
                }
            }
            
    return result;
}


auto GetTargetByCrossDist() {
    ASTExtraPlayerCharacter *result = 0;
    float max = std::numeric_limits<float>::infinity();

    auto GWorld = GetWorld();
    if (GWorld) {
        ULevel *PersistentLevel = GWorld->PersistentLevel;
        if (PersistentLevel) {
            TArray<AActor *> Actors = *(TArray<AActor *> *) ((uintptr_t) PersistentLevel + Actors_Offset);

            auto localPlayer = g_LocalPlayer;
            auto localController = g_LocalController;

            if (localPlayer) {
                for (int i = 0; i < Actors.Num(); i++) {
                    auto Actor = Actors[i];
                    if (isObjectInvalid(Actor))
                        continue;

                    if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass())) {
                        auto Player = (ASTExtraPlayerCharacter *) Actor;

                        if (Player->PlayerKey == localPlayer->PlayerKey)
                            continue;


                        if (Player->bDead)
                            continue;


                        if (Config.BulletTracking.VisCheck) {
                            if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                                continue;
                        }
                        /*
                         if (IgnoreBot) {
                    if (Player->bIsAI)
                        continue;
                }*/

                        auto Root = Player->GetBonePos("Root", {});
                        auto Head = Player->GetBonePos("Head", {});

                        FVector2D RootSc, HeadSc;
                        if (W2S(Root, &RootSc) && W2S(Head, &HeadSc)) {
                            float height = abs(HeadSc.Y - RootSc.Y);
                            float width = height * 0.65f;

                            FVector middlePoint = {HeadSc.X + (width / 2), HeadSc.Y + (height / 2), 0};
                            if ((middlePoint.X >= 0 && middlePoint.X <= glWidth) && (middlePoint.Y >= 0 && middlePoint.Y <= glHeight)) {
                                FVector2D v2Middle = FVector2D((float) (glWidth / 2), (float) (glHeight / 2));
                                FVector2D v2Loc = FVector2D(middlePoint.X, middlePoint.Y);

                                float dist = FVector2D::Distance(v2Middle, v2Loc);

                                if (dist < max) {
                                    max = dist;
                                    result = Player;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return result;
}



// ===========🅼🅰🅳🅴 🅱🆈  🅼🅾🅳 🆇================================ //

const char *GetVehicleName(ASTExtraVehicleBase *Vehicle) {
    switch (Vehicle->VehicleShapeType) {
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Motorbike:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Motorbike_SideCart:
            return "Motorbike";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Dacia:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_HeavyDacia:
            return "Dacia";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_MiniBus:
            return "Mini Bus";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_PickUp:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_PickUp01:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_HeavyPickup:
            return "Pick Up";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Buggy:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_HeavyBuggy:
            return "Buggy";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_UAZ:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_UAZ01:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_UAZ02:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_UAZ03:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_HeavyUAZ:
            return "UAZ";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_PG117:
            return "PG117";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Aquarail:
            return "Aquarail";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Mirado:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Mirado01:
            return "Mirado";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Rony:
            return "Rony";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Scooter:
            return "Scooter";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_SnowMobile:
            return "Snow Mobile";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_TukTukTuk:
            return "Tuk Tuk";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_SnowBike:
            return "Snow Bike";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Surfboard:
            return "Surf Board";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Snowboard:
            return "Snow Board";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Amphibious:
            return "Amphibious";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_LadaNiva:
            return "Lada Niva";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_UAV:
            return "UAV";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_MegaDrop:
            return "Mega Drop";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Lamborghini:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Lamborghini01:
            return "Lamborghini";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_GoldMirado:
            return "Gold Mirado";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_BigFoot:
            return "Big Foot";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_HeavyUH60:
            return "UH60";
            break;
        default:
            return "Vehicle";
            break;
    }
    return "Vehicle";
}

void (*orig_shoot_event)(USTExtraShootWeaponComponent *thiz, FVector start, FRotator rot, void *unk1, int unk2) = 0;
void shoot_event(USTExtraShootWeaponComponent *thiz, FVector start, FRotator rot, ASTExtraShootWeapon *weapon, int unk1) {
        if (Config.BulletTracking.Enable) {
        ASTExtraPlayerCharacter *Target = GetTargetByPussy();
        if (Target) {
            bool triggerOk = false;
            if (Config.BulletTracking.Trigger != EAimTrigger::None) {
                if (Config.BulletTracking.Trigger == EAimTrigger::Shooting) {
                    triggerOk = g_LocalPlayer->bIsWeaponFiring;
                } else if (Config.BulletTracking.Trigger == EAimTrigger::Scoping) {
                    triggerOk = g_LocalPlayer->bIsGunADS;
                } else if (Config.BulletTracking.Trigger == EAimTrigger::Both) {
                    triggerOk = g_LocalPlayer->bIsWeaponFiring && g_LocalPlayer->bIsGunADS;
                } else if (Config.BulletTracking.Trigger == EAimTrigger::Any) {
                    triggerOk = g_LocalPlayer->bIsWeaponFiring || g_LocalPlayer->bIsGunADS;
                }
            } else triggerOk = true;
            if (triggerOk) {
                FVector targetAimPos = Target->GetBonePos("Head", {});
                if (Config.BulletTracking.Target == EAimTarget::Chest) {
                    targetAimPos.Z -= 25.0f;
                    
                     
                    
               
                }

                UShootWeaponEntity *ShootWeaponEntityComponent = thiz->ShootWeaponEntityComponent;

				
			
                if (ShootWeaponEntityComponent) {
                    ASTExtraVehicleBase *CurrentVehicle = Target->CurrentVehicle;
                    if (CurrentVehicle) {
                        FVector LinearVelocity = CurrentVehicle->ReplicatedMovement.LinearVelocity;

                        float dist = g_LocalPlayer->GetDistanceTo(Target);
                        auto timeToTravel = dist / ShootWeaponEntityComponent->BulletRange;

                        targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(LinearVelocity, timeToTravel));
                    } else {
                        FVector Velocity = Target->GetVelocity();

                        float dist = g_LocalPlayer->GetDistanceTo(Target);
                        auto timeToTravel = dist / ShootWeaponEntityComponent->BulletRange;

                        targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(Velocity, timeToTravel));
                    }
                    FVector fDir = UKismetMathLibrary::Subtract_VectorVector(targetAimPos, start);
                    FRotator sex = UKismetMathLibrary::Conv_VectorToRotator(fDir);
                    rot = sex;
                }
            }
        }
    }

    return orig_shoot_event(thiz, start, rot, weapon, unk1);
}
	
	
	
	
void DrawBoxEnemy(ImDrawList *draw, ImVec2 X, ImVec2 Y, float thicc, int color) {
    draw->AddLine({X.x, X.y}, {Y.x, Y.y}, color, thicc);
}
//=====Bullettradck=====//
class FPSCounter {
protected:
    unsigned int m_fps;
    unsigned int m_fpscount;
    long m_fpsinterval;

public:
    FPSCounter() : m_fps(0), m_fpscount(0), m_fpsinterval(0) {
    }

    void update() {
        m_fpscount++;

        if (m_fpsinterval < time(0)) {
            m_fps = m_fpscount;

            m_fpscount = 0;
            m_fpsinterval = time(0) + 1;
        }
    }

    unsigned int get() const {
        return m_fps;
    }
};

FPSCounter fps;

void DrawFilledRectangle(int x, int y, int w, int h, ImU32 col, float rounding) {
    ImGui::GetBackgroundDrawList()->AddRectFilled(ImVec2(x, y), ImVec2(x + w, y + h), col, rounding);
}

void DrawRectangle(int x, int y, int w, int h, ImU32 col, float rounding) {
    ImGui::GetBackgroundDrawList()->AddRect(ImVec2(x, y), ImVec2(x + w, y + h), col, rounding);
}
bool W2S2(FVector worldPos, FVector2D *screenPos) {
    return g_LocalController->ProjectWorldLocationToScreen(worldPos, true, screenPos);
}

void Line(ImDrawList *draw,FVector2D origin, FVector2D dest, ImColor color)
{
   draw->AddLine({origin.X, origin.Y},{dest.X, dest.Y},color, 2.0f);
}


void Box3D(ImDrawList *draw, FVector origin, FVector extends, ImColor col) {
    origin.X -= extends.X / 2.f;
    origin.Y -= extends.Y / 2.f;
    origin.Z -= extends.Z / 2.f;
    
    
 FVector one = origin;
 FVector two = origin; two.X += extends.X;
 FVector tree = origin; tree.X += extends.X; tree.Y += extends.Y;
 FVector four = origin; four.Y += extends.Y;

 FVector five = one; five.Z += extends.Z;
 FVector six = two; six.Z += extends.Z;
 FVector seven = tree; seven.Z += extends.Z;
 FVector eight = four; eight.Z += extends.Z;

    FVector2D s1, s2, s3, s4, s5, s6, s7, s8;
    if (W2S2(one, &s1) && W2S2(two, &s2) && W2S2(tree, &s3) && W2S2(four, &s4) &&
    W2S2(five, &s5) && W2S2(six, &s6) && W2S2(seven, &s7) && W2S2(eight, &s8))
    {
        
    Line(draw,s1, s2, col);
    Line(draw,s2, s3, col);
    Line(draw,s3, s4, col);
    Line(draw,s4, s1, col);
 
    Line(draw,s5, s6, col);
    Line(draw,s6, s7, col);
    Line(draw,s7, s8, col);
    Line(draw,s8, s5, col);
 
    Line(draw,s1, s5, col);
    Line(draw,s2, s6, col);
    Line(draw,s3, s7, col);
    Line(draw,s4, s8, col);

}
}

/*void VectorAnglesRadar(Vector3 & forward, FVector & angles) {
 if (forward.X == 0.f && forward.Y == 0.f) {
  angles.X = forward.Z > 0.f ? -90.f : 90.f;
  angles.Y = 0.f;
 } else {
  angles.X = RAD2DEG(atan2(-forward.Z, forward.Magnitude(forward)));
  angles.Y = RAD2DEG(atan2(forward.Y, forward.X));
 }
 angles.Z = 0.f;
}

void RotateTriangle(std::array<Vector3, 3> & points, float rotation) {
 const auto points_center = (points.at(0) + points.at(1) + points.at(2)) / 3;
 for (auto & point : points) {
  point = point - points_center;
  const auto temp_x = point.X;
  const auto temp_y = point.Y;
  const auto theta = DEG2RAD(rotation);
  const auto c = cosf(theta);
  const auto s = sinf(theta);
  point.X = temp_x * c - temp_y * s;
  point.Y = temp_x * s + temp_y * c;
  point = point + points_center;
 }
} */



//===================== ESP DRAW =====================//

DefineHook(int, sub_288C090, (int a1, int a2))
{
    auto GWorld = GetWorld();
    if (GWorld){
        if (GWorld->NetDriver->ServerConnection)
            if(GWorld->NetDriver->ServerConnection->PlayerController){
                ASTExtraPlayerController *localController = (ASTExtraPlayerController *)GWorld->NetDriver->ServerConnection->PlayerController;
                uint32_t key =  *(int*)(a2 + 0x70);
                if(key == localController->PlayerKey){
                    ASTExtraPlayerCharacter *localPlayer = (ASTExtraPlayerCharacter *)localController->AcknowledgedPawn;
                    if (xsuit == 1)
					*(int*)(a2 + 0x94) = 1405909; //blood raven x suit
                    if (xsuit == 2)
                    *(int*)(a2 + 0x94) = 1405628; //Golden Pharaoh X-Suit
                    if (xsuit == 3)
                    *(int*)(a2 + 0x94) = 1406152; //Avalanche
                    if (xsuit == 4)
                    *(int*)(a2 + 0x94) = 1406475; //Irresidence
                    if (xsuit == 5)
                    *(int*)(a2 + 0x94) = 1405983; //Poseidon
                    if (xsuit == 6)
                    *(int*)(a2 + 0x94) = 1406638; //Arcane Jester X-suit
                    if (xsuit == 7)
                    *(int*)(a2 + 0x94) = 1406311; //Silvanus X-Sui
                    if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "AKM")){
						if (skinakm == 1)
                        *(int*)(a2 + 0x90) = 1101001042; //Sculpture - AKM
                        if (skinakm == 2)
                        *(int*)(a2 + 0x90) = 1101001063; //The Seven Seas - AKM
                        if (skinakm == 3)
                        *(int*)(a2 + 0x90) = 1101001068; //Roaring Tiger - AKM
                        if (skinakm == 4)
                        *(int*)(a2 + 0x90) = 1101001089; //Glacier - AKM
                        if (skinakm == 5)
                        *(int*)(a2 + 0x90) = 1101001101; //Desert Fossil - AKM
                        if (skinakm == 6)
                        *(int*)(a2 + 0x90) = 1101001116; //Jack-o'-lantern - AKM
                        if (skinakm == 7)
                        *(int*)(a2 + 0x90) = 1101001128; //Ghillie Dragon - AKM          
                        else if (skinakm == 8)
					    *(int*)(a2 + 0x90) = 1101001143; //Gold Pirate - AKM        		
					    else if (skinakm == 9)
					    *(int*)(a2 + 0x90) = 1101001174;
					   else if (skinakm == 10)
					    *(int*)(a2 + 0x90) = 1101001213;
					    else if (skinakm == 11)
					    *(int*)(a2 + 0x90) = 1101001023;
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "M416")){                  
                        if (skinm4 == 1) 
                            *(int*)(a2 + 0x90) = 1101004044; //Glacier - M416 
                        else if (skinm4 == 2) 
                            *(int*)(a2 + 0x90) = 1101004062; //The Fool - M416
                        else if (skinm4 == 3) 
                            *(int*)(a2 + 0x90) = 1101004086; //Lizard Roar - M416
						  else if (skinm4 == 4) 
                            *(int*)(a2 + 0x90) = 1101004078; //Wanderer - M416
                       else if (skinm4 == 5) 
                            *(int*)(a2 + 0x90) = 1101004098; //Call of the Wild - M416
                            else if (skinm4 == 6) 
                            *(int*)(a2 + 0x90) = 1101004163; //Imperial Splendor - M416
                            else if (skinm4 == 7) 
                            *(int*)(a2 + 0x90) = 1101004201; //Silver Guru - M416
                            else if (skinm4 == 8) 
                            *(int*)(a2 + 0x90) = 1101004138; //TechnoCore - M416
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "SCAR-L")){
                           if (skinscar == 1) 
                        *(int*)(a2 + 0x90) = 1101003057; //Water Blaster - SCAR-L
                       else if (skinscar == 2) 
						    *(int*)(a2 + 0x90) = 1101003070; //Enchanted Pumpkin - SCAR-L
						 else if (skinscar == 3) 
						    *(int*)(a2 + 0x90) = 1101003079; //Operation Tomorrow - SCAR-L
						 else if (skinscar == 4) 
						    *(int*)(a2 + 0x90) = 1101003099; //Drop the Bass - SCAR-L @kero_200
						    else if (skinscar == 5) 
						    *(int*)(a2 + 0x90) = 1101003119;
						    else if (skinscar == 6) 
						    *(int*)(a2 + 0x90) = 1101003146;
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "M762")){                  
                      if (skinm7 == 1) 
                        *(int*)(a2 + 0x90) = 1101003057; //8-bit Unicorn - M762
                       else if (skinm7 == 2) 
						    *(int*)(a2 + 0x90) = 1101008116; //Messi Football Icon M762
						 else if (skinm7 == 3) 
						    *(int*)(a2 + 0x90) = 1101008070; //GACKT MOONSAGA-M762
						 else if (skinm7 == 4) 
						    *(int*)(a2 + 0x90) = 1101008036; //Lotus Fury - M762
						    else if (skinm7 == 5)
						    *(int*)(a2 + 0x90) = 1101008051; //Concerto of Love - M762
						    else if (skinm7 == 6)
						    *(int*)(a2 + 0x90) = 1101008104; //StarCore-M762
						    else if (skinm7 == 7)
						    *(int*)(a2 + 0x90) = 1101008081; //Stray Rebellion - M762
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "GROZA")){
                    if (skingroza == 1) 
                        *(int*)(a2 + 0x90) = 1101005019;
                        if (skingroza == 2) 
                        *(int*)(a2 + 0x90) = 1101005052;
                        if (skingroza == 3) 
                        *(int*)(a2 + 0x90) = 1101005025; 
                        if (skingroza == 4) 
                        *(int*)(a2 + 0x90) = 1101005038; 
                        }
                    
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "UZI")){

if (skinuzi == 1) 
                        *(int*)(a2 + 0x90) = 1102001024; //Savagery - UZI
                        if (skinuzi == 2) 
                        *(int*)(a2 + 0x90) = 1102001036; //Ethereal Emblem - UZI
                        if (skinuzi == 3) 
                        *(int*)(a2 + 0x90) = 1102001058; //Romantic Moments - UZI
                        if (skinuzi == 4) 
                        *(int*)(a2 + 0x90) = 1102001069; //Shimmer Power - UZI
                      
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "UMP45")){

                      if (skinump45 == 1) 
                        *(int*)(a2 + 0x90) = 1102002043;
                        if (skinump45 == 2) 
                        *(int*)(a2 + 0x90) = 1102002053;
                        if (skinump45 == 3) 
                        *(int*)(a2 + 0x90) = 1102002061; 
                        if (skinump45 == 4) 
                        *(int*)(a2 + 0x90) = 1102002070; 
                        if (skinump45 == 5) 
                        *(int*)(a2 + 0x90) = 1102002030; 
                        if (skinump45 == 6) 
                        *(int*)(a2 + 0x90) = 1102002090; 
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "Vector")){

                        if (skinvector == 1) 
                        *(int*)(a2 + 0x90) = 1102003020;
                        if (skinvector == 2) 
                        *(int*)(a2 + 0x90) = 1102003031;
                        if (skinvector == 3) 
                        *(int*)(a2 + 0x90) = 1102003039; 
                        if (skinvector == 4) 
                        *(int*)(a2 + 0x90) = 1102003072; 
                        if (skinvector == 5) 
                        *(int*)(a2 + 0x90) = 1102003060; 
                      
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "Thompson")){

                        *(int*)(a2 + 0x90) = 1102004018; //candy cane
                      
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "PP-19 Bizon")){

if (skinbizon == 1) 
                        *(int*)(a2 + 0x90) = 1102005007;
                        if (skinbizon == 2) 
                        *(int*)(a2 + 0x90) = 1102005020;
                       
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "Kar98K")){

                        if (skinkar == 1) 
                        *(int*)(a2 + 0x90) = 1103001060;
                        if (skinkar == 2) 
                        *(int*)(a2 + 0x90) = 1103001079;
                        if (skinkar == 3) 
                        *(int*)(a2 + 0x90) = 1103001085; 
                        if (skinkar == 4) 
                        *(int*)(a2 + 0x90) = 1103001101;                       
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "M24")){

                        if (skinm24 == 1) 
                        *(int*)(a2 + 0x90) = 1103002018;
                        if (skinm24 == 2) 
                        *(int*)(a2 + 0x90) = 1103002030;
                        if (skinm24 == 3) 
                        *(int*)(a2 + 0x90) = 1103002049; 
                        if (skinm24 == 4) 
                        *(int*)(a2 + 0x90) = 1103002047; 
                        if (skinm24 == 5) 
                        *(int*)(a2 + 0x90) = 1103002059; 
                       
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "AWM")){

                        if (skinawm == 1) 
                        *(int*)(a2 + 0x90) = 1103003022;
                        if (skinawm == 2) 
                        *(int*)(a2 + 0x90) = 1103003030;
                        if (skinawm == 3) 
                        *(int*)(a2 + 0x90) = 1103003042; 
                        if (skinawm == 4) 
                        *(int*)(a2 + 0x90) = 1103003062; 
                       
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "DP28")){

                        if (skindp28 == 1) 
                        *(int*)(a2 + 0x90) = 1105002018;
                        if (skindp28 == 2) 
                        *(int*)(a2 + 0x90) = 1105002035;
                        
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "M16A4")){
                    if (skinm16a4 == 1) 
                        *(int*)(a2 + 0x90) = 1101002029;
                        if (skinm16a4 == 2) 
                        *(int*)(a2 + 0x90) = 1101002056;
                        if (skinm16a4 == 3) 
                        *(int*)(a2 + 0x90) = 1101002068; 
                        if (skinm16a4 == 4) 
                        *(int*)(a2 + 0x90) = 1101002081; 
                        }
                        else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "QBZ")){
                        if (skinqbz == 1) 
                        *(int*)(a2 + 0x90) = 1101007025;
                        if (skinqbz == 2) 
                        *(int*)(a2 + 0x90) = 1101007036;
                        if (skinqbz == 3) 
                        *(int*)(a2 + 0x90) = 1101007046;
                        }
                        else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "M249")){
                                                if (skinm249== 1) 
                        *(int*)(a2 + 0x90) = 1105001034;
                        if (skinm249== 2) 
                        *(int*)(a2 + 0x90) = 1105001020;
                        if (skinm249== 3) 
                        *(int*)(a2 + 0x90) = 1105001048;
                        }
                        else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "Mini 14")){
                        if (skinm16a4 == 1) 
                        *(int*)(a2 + 0x90) = 1101007025;
                        }
                        else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "SLR")){
                        if (skinslr == 1) 
                        *(int*)(a2 + 0x90) = 1103009022;
                        }
                        else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "SKS")){
                        if (skinsks == 1) 
                        *(int*)(a2 + 0x90) = 1103004037;
                        if (skinsks == 2) 
                        *(int*)(a2 + 0x90) = 1103004046;
                        if (skinsks == 3) 
                        *(int*)(a2 + 0x90) = 1103004058; 
                        }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "Pan")){

                        if (skinpan == 1) 
                        *(int*)(a2 + 0x90) = 1108004125;
                        if (skinpan == 2) 
                        *(int*)(a2 + 0x90) = 1108004145;
                        if (skinpan == 3) 
                        *(int*)(a2 + 0x90) = 1108004160; 
                         if (skinpan == 4) 
                        *(int*)(a2 + 0x90) = 1108004337; 
                        if (skinpan == 5) 
                        *(int*)(a2 + 0x90) = 1108004283; 
                    }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "Vss")){
                    if (skinvss == 1) 
                        *(int*)(a2 + 0x90) = 1103005024;
                        }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "MK14")){
                    if (skinmk14 == 1) 
                        *(int*)(a2 + 0x90) = 1103007020;
                        }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "S1897")){
                        if (skins1897 == 1) 
                        *(int*)(a2 + 0x90) = 1104002022;
                        }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "AUG")){
                    if (skinaug == 1) 
                        *(int*)(a2 + 0x90) = 1101006033;
                        }
                    else if(strstr(localPlayer->WeaponManagerComponent->CurrentWeaponReplicated->GetWeaponName().ToString(), "S12K")){
                        if (skins12k == 1) 
                        *(int*)(a2 + 0x90) = 1104003026;
                    }
                }
            }
    }
    return Orig_sub_288C090(a1, a2);
}

void DrawESP(ImDrawList *draw) {
if (g_LocalController == 0){
bool Bypass = true;
   } else {
bool ReportBlock = true;
    }
	 if (Config.Bypass) {	 

	}
	
time_t lt;
    struct tm *t_m;
    lt = time(NULL);
    t_m = localtime(&lt);

    int time_h = t_m->tm_hour;
    int time_m = t_m->tm_min;
    int time_s = t_m->tm_sec;

    std::string time;

    if (time_h < 10)
        time += "0";

    time += std::to_string(time_h) + ":";

    if (time_m < 10)
        time += "0";

    time += std::to_string(time_m) + ":";

    if (time_s < 10)
        time += "0";

    time += std::to_string(time_s);

if (Config.OTHER.HIDEESP) {
        HIDEESP = false;
    } else {
        HIDEESP = true;
    }
    if (HIDEESP) {
		
    auto GWorld = GetWorld();
    if (GWorld) {
        if (GWorld->PersistentLevel) {
            auto Actors = *(TArray<AActor *> *) ((uintptr_t) GWorld->PersistentLevel + Actors_Offset);

            int totalEnemies = 0, totalBots = 0;
            
            ASTExtraPlayerCharacter *localPlayer = 0;
            ASTExtraPlayerController *localController = 0;
                     

draw->AddText(NULL, ((float) density / 15.0f),{(float) glWidth / 150 + glWidth / 20,40},IM_COL32(0,255,0, 255),
                        " Made By Ubaydulla");
						
		if (Config.AimBot.Enable) {
draw->AddText({((float) density / 20.0f), 100}, IM_COL32(0, 255, 0, 255),
      ICON_FA_CROSSHAIRS"AimSimulation 2.0 -> (Opened)");
            }else{
        draw->AddText({((float) density / 20.0f), 100}, IM_COL32(255, 0, 0, 150),
                          "AimSimulation 2.0 -> (Closed)");        
}				

if (Config.AimBot.Enable) {
draw->AddCircle(ImVec2(glWidth / 2, glHeight / 2), FOVSize, IM_COL32(255, 0, 0, 100), 100, 0.0f);
}
						
				for (int i = 0; i < Actors.Num(); i++) {
                auto Actor = Actors[i];
                if (isObjectInvalid(Actor))
                    continue;

                if (Actor->IsA(ASTExtraPlayerController::StaticClass())) {
                    localController = (ASTExtraPlayerController *) Actor;
                    break;
                }
            }
		
			
            if (localController) {
                for (int i = 0; i < Actors.Num(); i++) {
                    auto Actor = Actors[i];
                    if (isObjectInvalid(Actor))
                        continue;

                    if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass())) {
                        if (((ASTExtraPlayerCharacter *) Actor)->PlayerKey == localController->PlayerKey) {
                            localPlayer = (ASTExtraPlayerCharacter *) Actor;
                            break;
                        }
                    }
                }


                                if (localPlayer) {
                    if (localPlayer->PartHitComponent) {
                        auto ConfigCollisionDistSqAngles = localPlayer->PartHitComponent->ConfigCollisionDistSqAngles;
                        for (int j = 0; j < ConfigCollisionDistSqAngles.Num(); j++) {
                            ConfigCollisionDistSqAngles[j].Angle = 180.0f;
                        }
                        localPlayer->PartHitComponent->ConfigCollisionDistSqAngles = ConfigCollisionDistSqAngles;
                    }
                      // static bool bShooting = false;
				if (Config.AimBot.Enable) {
                    ASTExtraPlayerCharacter *Target = GetTargetForAimBot();
                    if (Target) {
                        bool triggerOk = false;
                        if (Config.AimBot.Trigger != EAimTrigger::None) {
                            if (Config.AimBot.Trigger == EAimTrigger::Shooting) {
                                triggerOk = localPlayer->bIsWeaponFiring;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Scoping) {
                                triggerOk = localPlayer->bIsGunADS;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Both) {
                                triggerOk = localPlayer->bIsWeaponFiring && localPlayer->bIsGunADS;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Any) {
                                triggerOk = localPlayer->bIsWeaponFiring || localPlayer->bIsGunADS;
                            }
                        } else triggerOk = true;
                        if (triggerOk) {
                            FVector targetAimPos = Target->GetBonePos("Head", {});
                            if (Config.AimBot.Target == EAimTarget::Chest) {
                                targetAimPos.Z -= 25.0f;
                            }

                            auto WeaponManagerComponent = localPlayer->WeaponManagerComponent;
                            if (WeaponManagerComponent) {
                                auto propSlot = WeaponManagerComponent->GetCurrentUsingPropSlot();
                                if ((int) propSlot.GetValue() >= 1 &&
                                    (int) propSlot.GetValue() <= 3) {
                                    auto CurrentWeaponReplicated = (ASTExtraShootWeapon *) WeaponManagerComponent->CurrentWeaponReplicated;
                                    if (CurrentWeaponReplicated) {
                                        auto ShootWeaponComponent = CurrentWeaponReplicated->ShootWeaponComponent;
                                        if (ShootWeaponComponent) {
                                            UShootWeaponEntity *ShootWeaponEntityComponent = ShootWeaponComponent->ShootWeaponEntityComponent;
                                            if (ShootWeaponEntityComponent) {
                                                ASTExtraVehicleBase *CurrentVehicle = Target->CurrentVehicle;
                                                if (CurrentVehicle) {
                                                    FVector LinearVelocity = CurrentVehicle->ReplicatedMovement.LinearVelocity;

                                                    float dist = localPlayer->GetDistanceTo(Target);
                                                    auto timeToTravel = dist /
                                                                        ShootWeaponEntityComponent->BulletRange;

                                                    targetAimPos = UKismetMathLibrary::Add_VectorVector(
                                                            targetAimPos,
                                                            UKismetMathLibrary::Multiply_VectorFloat(
                                                                    LinearVelocity, timeToTravel));
                                                } else {
                                                    FVector Velocity = Target->GetVelocity();

                                                    float dist = localPlayer->GetDistanceTo(Target);
                                                    auto timeToTravel = dist /
                                                                        ShootWeaponEntityComponent->BulletRange;

                                                    targetAimPos = UKismetMathLibrary::Add_VectorVector(
                                                            targetAimPos,
                                                            UKismetMathLibrary::Multiply_VectorFloat(
                                                                    Velocity, timeToTravel));
                                                }
                                                			if (Config.AimBot.Enable) {
                            if (g_LocalPlayer->bIsGunADS) {
                               if (g_LocalPlayer->bIsWeaponFiring) {
                                float dist = localPlayer->GetDistanceTo(Target) / 100.f;                                                                                 
                                targetAimPos.Z -= dist * Config.Recc;        
                                
                                                          
                                }  
                             }
                           }  
												
							if (Config.AimBot.Predection) {
                            if (g_LocalPlayer->bIsGunADS) {
                               if (g_LocalPlayer->bIsWeaponFiring) {
                                float dist = localPlayer->GetDistanceTo(Target) / 98.f;                                                                                 
                                targetAimPos.Z -= dist * 1.050f;        
                                
                                                          
                                }  
                             }
                           }  
						   
												localController->SetControlRotation(ToRotator(localController->PlayerCameraManager->CameraCache.POV.Location, targetAimPos),"");
											}
										}
									}
								}
							}
						}
					}
				}

             
for (int i = 0; i < Actors.Num(); i++) {
    AActor* Actor = Actors[i];
    if (Actor == nullptr || Actor->IsPendingKill())
        continue;

    if (ACharacter* Character = Cast<ACharacter>(Actor)) {
        if (ASTExtraPlayerCharacter* Player = Cast<ASTExtraPlayerCharacter>(Character)) {
            float Distance = localPlayer->GetDistanceTo(Player) / 100.0f;
            if (Distance > Config.PlayerESP.DistanceMax)
                continue;

            if (Player->PlayerKey == localController->PlayerKey)
                continue;

            if (Player->TeamID == localController->TeamID)
                continue;

            if (Player->bDead)
                continue;

            if (Player->bIsAI)
                totalBots++;
            else
                totalEnemies++;

            if (Config.PlayerESP.NoBot && Player->bIsAI)
                continue;

            float magic_number = (Distance);
            float mx = (glWidth / 4) / magic_number;

            float healthLength = glWidth / 17;
            if (healthLength < mx)
                healthLength = mx;

            FVector HeadPos;
            if (!Player->GetBonePos("Head", HeadPos))
                continue;
            ImVec2 HeadPosSC;

            FVector RootPos;
            if (!Player->GetBonePos("Root", RootPos))
                continue;
            ImVec2 RootPosSC;

            FVector upper_r;
            if (!Player->GetBonePos("upperarm_r", upper_r))
                continue;
            ImVec2 upper_rPoSC;

            FVector lowerarm_r;
            if (!Player->GetBonePos("lowerarm_r", lowerarm_r))
                continue;
            ImVec2 lowerarm_rPoSC;

            FVector hand_r;
            if (!Player->GetBonePos("hand_r", hand_r))
                continue;
            ImVec2 hand_rPoSC;

            FVector upper_l;
            if (!Player->GetBonePos("upperarm_l", upper_l))
                continue;
            ImVec2 upper_lPoSC;

            FVector lowerarm_l;
            if (!Player->GetBonePos("lowerarm_l", lowerarm_l))
                continue;
            ImVec2 lowerarm_lSC;

            FVector hand_l;
            if (!Player->GetBonePos("hand_l", hand_l))
                continue;
            ImVec2 hand_lPoSC;

            FVector thigh_l;
            if (!Player->GetBonePos("thigh_l", thigh_l))
                continue;
            ImVec2 thigh_lPoSC;

            FVector calf_l;
            if (!Player->GetBonePos("calf_l", calf_l))
                continue;
            ImVec2 calf_lPoSC;

            FVector foot_l;
            if (!Player->GetBonePos("foot_l", foot_l))
                continue;
            ImVec2 foot_lPoSC;

            FVector thigh_r;
            if (!Player->GetBonePos("thigh_r", thigh_r))
                continue;
            ImVec2 thigh_rPoSC;

            FVector calf_r;
            if (!Player->GetBonePos("calf_r", calf_r))
                continue;
            ImVec2 calf_rPoSC;

            FVector foot_r;
            if (!Player->GetBonePos("foot_r", foot_r))
                continue;
            ImVec2 foot_rPoSC;

            FVector neck_01;
            if (!Player->GetBonePos("neck_01", neck_01))
                continue;
            ImVec2 neck_01PoSC;

            FVector pelvis;
            if (!Player->GetBonePos("pelvis", pelvis))
                continue;
            ImVec2 pelvisPoSC;

            bool IsVisible = localController->LineOfSightTo(Player, FVector::ZeroVector, true);

            int SCOLOR, SCOLOR2;

            if (IsVisible) {
                SCOLOR = ToColor(Config.ColorsESP.SkeletonVisible);
                SCOLOR2 = IM_COL32(0, 255, 0, 90);
            }
            else {
                SCOLOR = ToColor(Config.ColorsESP.Skeleton);
                SCOLOR2 = IM_COL32(255, 0, 0, 90);
            }

            if (W2S(HeadPos, (FVector2D*)&HeadPosSC) &&
                W2S(upper_r, (FVector2D*)&upper_rPoSC) &&
                W2S(lowerarm_r, (FVector2D*)&lowerarm_rPoSC) &&
                W2S(hand_r, (FVector2D*)&hand_rPoSC) &&
                W2S(upper_l, (FVector2D*)&upper_lPoSC) &&
                W2S(lowerarm_l, (FVector2D*)&lowerarm_lSC) &&
                W2S(hand_l, (FVector2D*)&hand_lPoSC) &&
                W2S(thigh_l, (FVector2D*)&thigh_lPoSC) &&
                W2S(calf_l, (FVector2D*)&calf_lPoSC) &&
                W2S(foot_l, (FVector2D*)&foot_lPoSC) &&
                W2S(thigh_r, (FVector2D*)&thigh_rPoSC) &&
                W2S(calf_r, (FVector2D*)&calf_rPoSC) &&
                W2S(foot_r, (FVector2D*)&foot_rPoSC) &&
                W2S(neck_01, (FVector2D*)&neck_01PoSC) &&
                W2S(pelvis, (FVector2D*)&pelvisPoSC)) {

                if (Distance < 350.0f && (totalEnemies > 0 || totalBots > 0)) {
                    if (Config.PlayerESP.Line) {
                        draw->AddLine(ImVec2(glWidth / 2, 0), ImVec2(HeadPosSC.x, HeadPosSC.y - 55.0f), SCOLOR2, 1.5f);
                    }

                    if (Config.PlayerESP.Box) {
                        FVector BoxSize(60.f, 75.f, 165.f);
                        Box3D(draw, Player->K2_GetActorLocation(), BoxSize, SCOLOR2);
                    }

                    if (Config.PlayerESP.Skeleton) {
                        draw->AddLine(upper_rPoSC, neck_01PoSC, SCOLOR, 1.5f);
                        draw->AddLine(upper_lPoSC, neck_01PoSC, SCOLOR, 1.5f);

                        draw->AddLine(upper_rPoSC, lowerarm_rPoSC, SCOLOR, 1.5f);
                        draw->AddLine(lowerarm_rPoSC, hand_rPoSC, SCOLOR, 1.5f);

                        draw->AddLine(upper_lPoSC, lowerarm_lSC, SCOLOR, 1.5f);
                        draw->AddLine(lowerarm_lSC, hand_lPoSC, SCOLOR, 1.5f);

                        draw->AddLine(thigh_rPoSC, thigh_lPoSC, SCOLOR, 1.5f);

                        draw->AddLine(thigh_lPoSC, calf_lPoSC, SCOLOR, 1.5f);
                        draw->AddLine(calf_lPoSC, foot_lPoSC, SCOLOR, 1.5f);

                        draw->AddLine(thigh_rPoSC, calf_rPoSC, SCOLOR, 1.5f);
                        draw->AddLine(calf_rPoSC, foot_rPoSC, SCOLOR, 1.5f);

                        draw->AddLine(neck_01PoSC, pelvisPoSC, SCOLOR, 1.5f);
                        draw->AddLine(neck_01PoSC, HeadPosSC, SCOLOR, 1.5f);
                    }

                    if (Config.PlayerESP.Health) {
                        int CurHP = (int)std::max(0, std::min((int)Player->Health, (int)Player->HealthMax));
                        int MaxHP = (int)Player->HealthMax;

                        uint32_t HPColor;
                        if (Player->Health < 25)
                            HPColor = IM_COL32(0, 203, 255, 110);
                        else if (Player->Health < 50)
                            HPColor = IM_COL32(255, 0, 233, 120);
                        else if (Player->Health < 75)
                            HPColor = IM_COL32(255, 0, 233, 120);
                        else
                            HPColor = SCOLOR2;

                        if (Player->Health == 0.0f && !Player->bDead) {
                            SCOLOR2 = IM_COL32(250, 0, 0, 80);
                            HPColor = IM_COL32(255, 0, 0, 110);
                            CurHP = Player->NearDeathBreath;
                            if (Player->NearDeatchComponent) {
                                MaxHP = Player->NearDeatchComponent->BreathMax;
                            }
                        }

                        float boxWidth = density / 1.50f;
                        boxWidth -= std::min(((boxWidth / 2) / 0.00f) * Distance, boxWidth / 2);
                        float boxHeight = boxWidth * 0.15f;

                        ImVec2 vStart = { HeadPosSC.x - (boxWidth / 2), HeadPosSC.y - (boxHeight * 1.5f) };
                        ImVec2 vEndFilled = { vStart.x + (CurHP * boxWidth / MaxHP), vStart.y + boxHeight };
                        ImVec2 vEndRect = { vStart.x + boxWidth, vStart.y + boxHeight };

                        draw->AddRectFilled(vStart, vEndFilled, HPColor, 10.0f);
                        draw->AddRect(vStart, vEndRect, SCOLOR2, 10.0f);
                    }

                    if (Config.PlayerESP.TeamID) {
                        std::string s = std::to_string((int)Player->TeamID) + "-]";
                        draw->AddText(nullptr, 20.f, ImVec2(HeadPosSC.x - 65, HeadPosSC.y - 32.0f), IM_COL32(255, 255, 255, 255), s.c_str());
                    }

                    if (Config.PlayerESP.Name) {
                        std::string s;
                        if (Player->bIsAI) {
                            s += "   BOT";
                        }
                        else {
                            s += Player->PlayerName.ToString();
                        }
                        draw->AddText(nullptr, 20.f, ImVec2(HeadPosSC.x - 30, HeadPosSC.y - 32.0f), IM_COL32(255, 255, 255, 255), s.c_str());
                    }

                    if (Config.PlayerESP.Distance) {
                        std::string s = "[" + std::to_string((int)Distance) + "-M]";
                        draw->AddText(nullptr, 20.f, ImVec2(HeadPosSC.x + healthLength - 60, HeadPosSC.y - 65.0f), IM_COL32(255, 255, 255, 255), s.c_str());
                    }

                    if (Config.PlayerESP.Weapon) {
                        auto WeaponManagerComponent = Player->WeaponManagerComponent;
                        if (WeaponManagerComponent) {
                            auto CurrentWeaponReplicated = Cast<ASTExtraShootWeapon>(WeaponManagerComponent->CurrentWeaponReplicated);
                            if (CurrentWeaponReplicated) {
                                auto WeaponId = (int)CurrentWeaponReplicated->GetWeaponID();
                                if (WeaponId) {
                                    std::string s = "[" + CurrentWeaponReplicated->GetWeaponName().ToString() + "]";
                                    auto textSize = ImGui::CalcTextSize(s.c_str(), 0, ((float)density / 30.0f));
                                    draw->AddText(nullptr, 20.f, ImVec2(HeadPosSC.x + healthLength - 175, HeadPosSC.y - 65.0f), IM_COL32(255, 255, 255, 255), s.c_str());
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if (APickUpWrapperActor* PickUp = Cast<APickUpWrapperActor>(Actor)) {
        if (Items[PickUp->DefineID.TypeSpecificID]) {
            auto RootComponent = PickUp->RootComponent;
            if (!RootComponent)
                continue;

            float Distance = PickUp->GetDistanceTo(localPlayer) / 100.f;

            FVector2D itemPos;
            if (W2S(PickUp->K2_GetActorLocation(), &itemPos)) {
                std::string s;
                uint32_t tc = 0xFF000000;

                for (auto& category : items_data) {
                    for (auto& item : category["Items"]) {
                        if (item["itemId"] == PickUp->DefineID.TypeSpecificID) {
                            s = item["itemName"].get<std::string>();
                            tc = strtoul(item["itemTextColor"].get<std::string>().c_str(), 0, 16);
                            break;
                        }
                    }
                }

                s += " - ";
                s += std::to_string((int)Distance);
                s += "m";

                draw->AddText(nullptr, ((float)density / 30.0f), { itemPos.X, itemPos.Y }, tc, s.c_str());
            }
        }
    }
}

//====================== //
           g_LocalController = localController;
		g_LocalPlayer = localPlayer;
        if (totalEnemies > 0 || totalBots > 0)
        {
           std::string s;
          //  if (totalEnemies + totalBots < 10)
            {          
              s += "E-";
              s += std::to_string((int)totalEnemies);
              s += " | ";
              s += "B-";
              s += std::to_string((int)totalBots);                         
            }
        //    s += std::to_string((int) totalEnemies + totalBots);
			draw->AddRectFilled(ImVec2(glWidth / 2 - 80, 50), ImVec2(glWidth / 2 + 80, 90), IM_COL32(0, 150, 255, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 72, 50), ImVec2(glWidth / 2 + 72, 90), IM_COL32(0, 150, 255, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 64, 50), ImVec2(glWidth / 2 + 64, 90), IM_COL32(0, 150, 255, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 60, 50), ImVec2(glWidth / 2 + 60, 90), IM_COL32(0, 150, 255, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 56, 50), ImVec2(glWidth / 2 + 56, 90), IM_COL32(0, 150, 255, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 52, 50), ImVec2(glWidth / 2 + 52, 90), IM_COL32(0, 150, 255, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 48, 50), ImVec2(glWidth / 2 + 48, 90), IM_COL32(0, 150, 255, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 44, 50), ImVec2(glWidth / 2 + 44, 90), IM_COL32(0, 150, 255, 38));
            draw->AddText(nullptr, ((float) density / 12.5f), ImVec2(glWidth / 2 - 65.f, 50), IM_COL32(1, 1, 1, 255), s.c_str());
        } else{
            std::string s;
            s += "CLEAR";
            draw->AddRectFilled(ImVec2(glWidth / 2 - 80, 50), ImVec2(glWidth / 2 + 80, 90), IM_COL32(0, 255, 0, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 72, 50), ImVec2(glWidth / 2 + 72, 90), IM_COL32(0, 255, 0, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 64, 50), ImVec2(glWidth / 2 + 64, 90), IM_COL32(0, 255, 0, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 60, 50), ImVec2(glWidth / 2 + 60, 90), IM_COL32(0, 255, 0, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 56, 50), ImVec2(glWidth / 2 + 56, 90), IM_COL32(0, 255, 0, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 52, 50), ImVec2(glWidth / 2 + 52, 90), IM_COL32(0, 255, 0, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 48, 50), ImVec2(glWidth / 2 + 48, 90), IM_COL32(0, 255, 0, 38));
            draw->AddRectFilled(ImVec2(glWidth / 2 - 44, 50), ImVec2(glWidth / 2 + 44, 90), IM_COL32(0, 255, 0, 38));
            draw->AddText(nullptr, ((float) density / 12.5f), ImVec2(glWidth / 2 - 50.f, 50), IM_COL32(1, 1, 1, 255), s.c_str());
        }
          	if (Config.AimBot.Cross) {
   //  draw->AddCircle(ImVec2(screenWidth / 3.0f, screenHeight / 3.0f), Config.AimBot.Cross*0.7f, ToColor(Config.ColorsESP.Fov), 500, 0.0f);
     draw->AddCircle(ImVec2(glWidth / 2.0, glHeight / 2.0), Config.AimBot.Cross*1.0f, IM_COL32(255, 255, 255, 255),100, 0.7f);
           } 
        }
	}
	}
	}
    }
// ==========ROBION========================== //

std::string getClipboardText() {
    if (!g_App)
        return "";

    auto activity = g_App->activity;
    if (!activity)
        return "";

    auto vm = activity->vm;
    if (!vm)
        return "";

    auto object = activity->clazz;
    if (!object)
        return "";

    std::string result;

    JNIEnv *env;
    vm->AttachCurrentThread(&env, 0);
    {
        auto ContextClass = env->FindClass("android/content/Context");
        auto getSystemServiceMethod = env->GetMethodID(ContextClass, "getSystemService", "(Ljava/lang/String;)Ljava/lang/Object;");
        auto str = env->NewStringUTF("clipboard");
        auto clipboardManager = env->CallObjectMethod(object, getSystemServiceMethod, str);
        env->DeleteLocalRef(str);
        auto ClipboardManagerClass = env->FindClass("android/content/ClipboardManager");
        auto getText = env->GetMethodID(ClipboardManagerClass, "getText", "()Ljava/lang/CharSequence;");
        auto CharSequenceClass = env->FindClass("java/lang/CharSequence");
        auto toStringMethod = env->GetMethodID(CharSequenceClass, "toString", "()Ljava/lang/String;");
        auto text = env->CallObjectMethod(clipboardManager, getText);
        if (text) {
            str = (jstring) env->CallObjectMethod(text, toStringMethod);
            result = env->GetStringUTFChars(str, 0);
            env->DeleteLocalRef(str);
            env->DeleteLocalRef(text);
        }

        env->DeleteLocalRef(CharSequenceClass);
        env->DeleteLocalRef(ClipboardManagerClass);
        env->DeleteLocalRef(clipboardManager);
        env->DeleteLocalRef(ContextClass);
    }
    vm->DetachCurrentThread();

    return result;
}
// ======================================================================== //
const char *GetAndroidID(JNIEnv *env, jobject context) {
    jclass contextClass = env->FindClass(/*android/content/Context*/ StrEnc("`L+&0^[S+-:J^$,r9q92(as", "\x01\x22\x4F\x54\x5F\x37\x3F\x7C\x48\x42\x54\x3E\x3B\x4A\x58\x5D\x7A\x1E\x57\x46\x4D\x19\x07", 23).c_str());
    jmethodID getContentResolverMethod = env->GetMethodID(contextClass, /*getContentResolver*/ StrEnc("E8X\\7r7ys_Q%JS+L+~", "\x22\x5D\x2C\x1F\x58\x1C\x43\x1C\x1D\x2B\x03\x40\x39\x3C\x47\x3A\x4E\x0C", 18).c_str(), /*()Landroid/content/ContentResolver;*/ StrEnc("8^QKmj< }5D:9q7f.BXkef]A*GYLNg}B!/L", "\x10\x77\x1D\x2A\x03\x0E\x4E\x4F\x14\x51\x6B\x59\x56\x1F\x43\x03\x40\x36\x77\x28\x0A\x08\x29\x24\x44\x33\x0B\x29\x3D\x08\x11\x34\x44\x5D\x77", 35).c_str());
    jclass settingSecureClass = env->FindClass(/*android/provider/Settings$Secure*/ StrEnc("T1yw^BCF^af&dB_@Raf}\\FS,zT~L(3Z\"", "\x35\x5F\x1D\x05\x31\x2B\x27\x69\x2E\x13\x09\x50\x0D\x26\x3A\x32\x7D\x32\x03\x09\x28\x2F\x3D\x4B\x09\x70\x2D\x29\x4B\x46\x28\x47", 32).c_str());
    jmethodID getStringMethod = env->GetStaticMethodID(settingSecureClass, /*getString*/ StrEnc("e<F*J5c0Y", "\x02\x59\x32\x79\x3E\x47\x0A\x5E\x3E", 9).c_str(), /*(Landroid/content/ContentResolver;Ljava/lang/String;)Ljava/lang/String;*/ StrEnc("$6*%R*!XO\"m18o,0S!*`uI$IW)l_/_knSdlRiO1T`2sH|Ouy__^}%Y)JsQ:-\"(2_^-$i{?H", "\x0C\x7A\x4B\x4B\x36\x58\x4E\x31\x2B\x0D\x0E\x5E\x56\x1B\x49\x5E\x27\x0E\x69\x0F\x1B\x3D\x41\x27\x23\x7B\x09\x2C\x40\x33\x1D\x0B\x21\x5F\x20\x38\x08\x39\x50\x7B\x0C\x53\x1D\x2F\x53\x1C\x01\x0B\x36\x31\x39\x46\x0C\x15\x43\x2B\x05\x30\x15\x41\x43\x46\x55\x70\x0D\x59\x56\x00\x15\x58\x73", 71).c_str());

    auto obj = env->CallObjectMethod(context, getContentResolverMethod);
    auto str = (jstring) env->CallStaticObjectMethod(settingSecureClass, getStringMethod, obj, env->NewStringUTF(/*android_id*/ StrEnc("ujHO)8OfOE", "\x14\x04\x2C\x3D\x46\x51\x2B\x39\x26\x21", 10).c_str()));
    return env->GetStringUTFChars(str, 0);
}

const char *GetDeviceModel(JNIEnv *env) {
    jclass buildClass = env->FindClass(/*android/os/Build*/ StrEnc("m5I{GKGWBP-VOxkA", "\x0C\x5B\x2D\x09\x28\x22\x23\x78\x2D\x23\x02\x14\x3A\x11\x07\x25", 16).c_str());
    jfieldID modelId = env->GetStaticFieldID(buildClass, /*MODEL*/ StrEnc("|}[q:", "\x31\x32\x1F\x34\x76", 5).c_str(), /*Ljava/lang/String;*/ StrEnc(".D:C:ETZ1O-Ib&^h.Y", "\x62\x2E\x5B\x35\x5B\x6A\x38\x3B\x5F\x28\x02\x1A\x16\x54\x37\x06\x49\x62", 18).c_str());

    auto str = (jstring) env->GetStaticObjectField(buildClass, modelId);
    return env->GetStringUTFChars(str, 0);
}

const char *GetDeviceBrand(JNIEnv *env) {
    jclass buildClass = env->FindClass(/*android/os/Build*/ StrEnc("0iW=2^>0zTRB!B90", "\x51\x07\x33\x4F\x5D\x37\x5A\x1F\x15\x27\x7D\x00\x54\x2B\x55\x54", 16).c_str());
    jfieldID modelId = env->GetStaticFieldID(buildClass, /*BRAND*/ StrEnc("@{[FP", "\x02\x29\x1A\x08\x14", 5).c_str(), /*Ljava/lang/String;*/ StrEnc(".D:C:ETZ1O-Ib&^h.Y", "\x62\x2E\x5B\x35\x5B\x6A\x38\x3B\x5F\x28\x02\x1A\x16\x54\x37\x06\x49\x62", 18).c_str());

    auto str = (jstring) env->GetStaticObjectField(buildClass, modelId);
    return env->GetStringUTFChars(str, 0);
}

const char *GetPackageName(JNIEnv *env, jobject context) {
    jclass contextClass = env->FindClass(/*android/content/Context*/ StrEnc("`L+&0^[S+-:J^$,r9q92(as", "\x01\x22\x4F\x54\x5F\x37\x3F\x7C\x48\x42\x54\x3E\x3B\x4A\x58\x5D\x7A\x1E\x57\x46\x4D\x19\x07", 23).c_str());
    jmethodID getPackageNameId = env->GetMethodID(contextClass, /*getPackageName*/ StrEnc("YN4DaP)!{wRGN}", "\x3E\x2B\x40\x14\x00\x33\x42\x40\x1C\x12\x1C\x26\x23\x18", 14).c_str(), /*()Ljava/lang/String;*/ StrEnc("VnpibEspM(b]<s#[9cQD", "\x7E\x47\x3C\x03\x03\x33\x12\x5F\x21\x49\x0C\x3A\x13\x20\x57\x29\x50\x0D\x36\x7F", 20).c_str());

    auto str = (jstring) env->CallObjectMethod(context, getPackageNameId);
    return env->GetStringUTFChars(str, 0);
}

const char *GetDeviceUniqueIdentifier(JNIEnv *env, const char *uuid) {
    jclass uuidClass = env->FindClass(/*java/util/UUID*/ StrEnc("B/TxJ=3BZ_]SFx", "\x28\x4E\x22\x19\x65\x48\x47\x2B\x36\x70\x08\x06\x0F\x3C", 14).c_str());

    auto len = strlen(uuid);

    jbyteArray myJByteArray = env->NewByteArray(len);
    env->SetByteArrayRegion(myJByteArray, 0, len, (jbyte *) uuid);

    jmethodID nameUUIDFromBytesMethod = env->GetStaticMethodID(uuidClass, /*nameUUIDFromBytes*/ StrEnc("P6LV|'0#A+zQmoat,", "\x3E\x57\x21\x33\x29\x72\x79\x67\x07\x59\x15\x3C\x2F\x16\x15\x11\x5F", 17).c_str(), /*([B)Ljava/util/UUID;*/ StrEnc("sW[\"Q[W3,7@H.vT0) xB", "\x5B\x0C\x19\x0B\x1D\x31\x36\x45\x4D\x18\x35\x3C\x47\x1A\x7B\x65\x7C\x69\x3C\x79", 20).c_str());
    jmethodID toStringMethod = env->GetMethodID(uuidClass, /*toString*/ StrEnc("2~5292eW", "\x46\x11\x66\x46\x4B\x5B\x0B\x30", 8).c_str(), /*()Ljava/lang/String;*/ StrEnc("P$BMc' #j?<:myTh_*h0", "\x78\x0D\x0E\x27\x02\x51\x41\x0C\x06\x5E\x52\x5D\x42\x2A\x20\x1A\x36\x44\x0F\x0B", 20).c_str());

    auto obj = env->CallStaticObjectMethod(uuidClass, nameUUIDFromBytesMethod, myJByteArray);
    auto str = (jstring) env->CallObjectMethod(obj, toStringMethod);
    return env->GetStringUTFChars(str, 0);
}

struct MemoryStruct {
    char *memory;
    size_t size;
};

static size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    struct MemoryStruct *mem = (struct MemoryStruct *) userp;

    mem->memory = (char *) realloc(mem->memory, mem->size + realsize + 1);
    if (mem->memory == NULL) {
        return 0;
    }

    memcpy(&(mem->memory[mem->size]), contents, realsize);
    mem->size += realsize;
    mem->memory[mem->size] = 0;

    return realsize;
}

//=========================MAIN LOGIN =================//
std::string Login(const char *user_key) {
    if (!g_App)
        return "Internal Error";

    auto activity = g_App->activity;
    if (!activity)
        return "Internal Error";

    auto vm = activity->vm;
    if (!vm)
        return "Internal Error";

    auto object = activity->clazz;
    if (!object)
        return "Internal Error";

    JNIEnv *env;
    vm->AttachCurrentThread(&env, 0);

    std::string hwid = user_key;
    hwid += GetAndroidID(env, object);
    hwid += GetDeviceModel(env);
    hwid += GetDeviceBrand(env);

    std::string UUID = GetDeviceUniqueIdentifier(env, hwid.c_str());

    vm->DetachCurrentThread();

    std::string errMsg;

    struct MemoryStruct chunk{};
    chunk.memory = (char *) malloc(1);
    chunk.size = 0;

    CURL *curl;
    CURLcode res;
    curl = curl_easy_init();
      	std::string URL  = "";
       if (curl) {
        curl_easy_setopt(curl, CURLOPT_URL, "https://vipkeypubg.xyz/connect");

        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
        curl_easy_setopt(curl, CURLOPT_DEFAULT_PROTOCOL, /*https*/ StrEnc("!mLBO", "\x49\x19\x38\x32\x3C", 5).c_str());
        struct curl_slist *headers = NULL;
        headers = curl_slist_append(headers, /*Content-Type: application/x-www-form-urlencoded*/ StrEnc("@;Ls\\(KP4Qrop`b#d3094/r1cf<c<=H)AiiBG6i|Ta66s2[", "\x03\x54\x22\x07\x39\x46\x3F\x7D\x60\x28\x02\x0A\x4A\x40\x03\x53\x14\x5F\x59\x5A\x55\x5B\x1B\x5E\x0D\x49\x44\x4E\x4B\x4A\x3F\x04\x27\x06\x1B\x2F\x6A\x43\x1B\x10\x31\x0F\x55\x59\x17\x57\x3F", 47).c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

        char data[4096];
        sprintf(data, /*game=PUBG&user_key=%s&serial=%s*/ StrEnc("qu2yXK,YkJyGD@ut0.u~Nb'5(:.:chK", "\x16\x14\x5F\x1C\x65\x1B\x79\x1B\x2C\x6C\x0C\x34\x21\x32\x2A\x1F\x55\x57\x48\x5B\x3D\x44\x54\x50\x5A\x53\x4F\x56\x5E\x4D\x38", 31).c_str(), user_key, UUID.c_str());
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);

        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) &chunk);

        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);

        res = curl_easy_perform(curl);
        if (res == CURLE_OK) {
            try {
                json result = json::parse(chunk.memory);
                                                if (result[/*status*/ StrEnc("(>_LBm", "\x5B\x4A\x3E\x38\x37\x1E", 6).c_str()] == true) {
                    rng = result[/*data*/ StrEnc("fAVA", "\x02\x20\x22\x20", 4).c_str()][/*rng*/ StrEnc("+n,", "\x59\x00\x4B", 3).c_str()].get<time_t>();
                    //   expiredDate = result[/*data*/ StrEnc("fAVA", "\x02\x20\x22\x20", 4).c_str()][/*ts*/ StrEnc("4`", "\x40\x13", 2).c_str()].get<std::string>();
                    //  modStatus = result[/*data*/ StrEnc("fAVA", "\x02\x20\x22\x20", 4).c_str()][/*ms*/ StrEnc("#e", "\x4E\x16", 2).c_str()].get<std::string>();
                    std::string token = result[/*data*/ StrEnc("fAVA", "\x02\x20\x22\x20", 4).c_str()][/*token*/ StrEnc("{>3Lr", "\x0F\x51\x58\x29\x1C", 5).c_str()].get<std::string>();
                    time_t rng = result[/*data*/ StrEnc("fAVA", "\x02\x20\x22\x20", 4).c_str()][/*rng*/ StrEnc("+n,", "\x59\x00\x4B", 3).c_str()].get<time_t>();
                    if (rng + 30 > time(0)) {
                        std::string auth = /*PUBG*/ StrEnc("Q*) ", "\x01\x7F\x6B\x67", 4).c_str();;
                        auth += "-";
                        auth += user_key;
                        auth += "-";
                        auth += UUID;
                        auth += "-";
                        auth += /*Vm8Lk7Uj2JmsjCPVPVjrLa7zgfx3uz9E*/ StrEnc("-2:uwZdV^%]?{{wHs2V,+(^NJU;kC*_{", "\x7B\x5F\x02\x39\x1C\x6D\x31\x3C\x6C\x6F\x30\x4C\x11\x38\x27\x1E\x23\x64\x3C\x5E\x67\x49\x69\x34\x2D\x33\x43\x58\x36\x50\x66\x3E", 32).c_str();
                        std::string outputAuth = Tools::CalcMD5(auth);
     
                        g_Token = token;
                        g_Auth = outputAuth;
				
                        bValid = g_Token == g_Auth;
                    }
                } else {
                    errMsg = result[/*reason*/ StrEnc("LW(3(c", "\x3E\x32\x49\x40\x47\x0D", 6).c_str()].get<std::string>();
                }
            } catch (json::exception &e) {
                errMsg = "{";
                errMsg += e.what();
                errMsg += "}\n{";
                errMsg += chunk.memory;
                errMsg += "}";
            }
        } else {
            errMsg = curl_easy_strerror(res);
        }
    }
    curl_easy_cleanup(curl);

    return bValid ? "OK" : errMsg;
}

int Jatin_FLOAT(long int addr, float value){
    Tools::WriteAddr((void*)(addr), (void*)&value , 4);
    return 0;
}

int Jatin_QWORD(long int addr, int64_t value){
    Tools::WriteAddr((void*)(addr),(void*)&value ,sizeof(value));
    return 0;
}

void *run_thread(void *arguments) {

    switch((int)arguments){

        int dValue;
        float fValue;

     /*   case 1:
            if(Config.MemoryHacks.LessRecoil){
                fValue = 0;
                Tools::WriteAddr((void*)(g_UE4 + 0x248e080), (void*)&fValue , 4);
            } else {
                fValue = -2.78698203e28;
                Tools::WriteAddr((void*)(g_UE4 + 0x248e080), (void*)&fValue , 4);
            }
            break;

        case 2:
            if(Config.MemoryHacks.RemoveFog){
                dValue = 0;
                Tools::WriteAddr((void*)(g_UE4 + 0x45a44c8), (void*)&dValue , 4);
            } else {
                dValue = -298841535;
                Tools::WriteAddr((void*)(g_UE4 + 0x45a44c8), (void*)&dValue , 4);
            }
            break;

        case 3:
            if(Config.MemoryHacks.StaticCross){
                fValue = 0.0f;
                Tools::WriteAddr((void*)(g_UE4 + 0x143046C), (void*)&fValue , 4);
            } else {
                fValue = -1.1144502e28f;
                Tools::WriteAddr((void*)(g_UE4 + 0x143046C), (void*)&fValue , 4);
            }
            break;

        case 4:
            if(Config.MemoryHacks.WallLoot){
                dValue = 0;
                Tools::WriteAddr((void*)(g_UE4 + 0x4c5f0fc), (void*)&dValue , 4);
            } else {
                dValue = 1241514129;
                Tools::WriteAddr((void*)(g_UE4 + 0x4c5f0fc), (void*)&dValue , 4);
            }
            break;

        case 5:
            if(Config.MemoryHacks.Xkill){
                dValue = 0;
                Tools::WriteAddr((void*)(g_UE4 + 0x2CAF500), (void*)&dValue , 4);
            } else {
                dValue = -299365883;
                Tools::WriteAddr((void*)(g_UE4 + 0x2CAF500), (void*)&dValue , 4);
            }
            break;
*/
        case 6:
            if(Config.MemoryHacks.Aimbot){
                dValue = 0;
                Tools::WriteAddr((void*)(g_UE4 + 0x3dbba6c ), (void*)&dValue , 4);
            } else {
                dValue = 2015175168;
                Tools::WriteAddr((void*)(g_UE4 + 0x3dbba6c), (void*)&dValue , 4);
            }
           break;

        case 7:
            if(Config.MemoryHacks.CarFly){
                dValue = 0;
                Tools::WriteAddr((void*)(g_UE4 + 0x64e68cc), (void*)&dValue , 4);
            } else {
                dValue = -289961472;
                Tools::WriteAddr((void*)(g_UE4 + 0x64e68cc), (void*)&dValue , 4);
            }
           break;

        case 10:
            if(Config.MemoryHacks.FixStuck){
                Jatin_FLOAT(g_UE4 + 0x23d3c9c, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3c0c, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3bf0, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3bd4, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3b48, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3b30, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3b04, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3ac4, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a74, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a70, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a6c, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a68, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a5c, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a54, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a38, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a34, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a30, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a2c, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a24, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a20, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a1c, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a14, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a0c, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a04, 0);
                Jatin_FLOAT(g_UE4 + 0x23d3a00, 0);
            } else {
                Jatin_FLOAT(g_UE4 + 0x23d3c9c, 100.0);
                Jatin_FLOAT(g_UE4 + 0x23d3c0c, 0.00048828148);
                Jatin_FLOAT(g_UE4 + 0x23d3bf0, 0.00048828148);
                Jatin_FLOAT(g_UE4 + 0x23d3bd4, 0.00048828148);
                Jatin_FLOAT(g_UE4 + 0x23d3b48, -7.52316564e-37);
                Jatin_FLOAT(g_UE4 + 0x23d3b30, -7.52317102e-37);
                Jatin_FLOAT(g_UE4 + 0x23d3b04, 2.52532605e-28);
                Jatin_FLOAT(g_UE4 + 0x23d3ac4, 1.61716794e-27);
                Jatin_FLOAT(g_UE4 + 0x23d3a74, -1.11735158e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a70, -1.13427654e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a6c, -1.12605584e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a68, -2.92528314e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a5c, -2.92721931e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a54, -2.92625241e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a38, -1.11493373e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a34, -1.05255315e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a30, -1.43989204e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a2c, -1.43167135e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a24, -1.25033153e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a20, -9.98876847e27);
                Jatin_FLOAT(g_UE4 + 0x23d3a1c, -1.12218728e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a14, -1.25855222e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a0c, -1.24646297e28);
                Jatin_FLOAT(g_UE4 + 0x23d3a04, -9.98393277e27);
                Jatin_FLOAT(g_UE4 + 0x23d3a00, -6.15262313e27);
            }
          break;

        case 12:
            if(Config.MemoryHacks.SlowMotion){
                Jatin_FLOAT(g_UE4 + 0x54b1580, 0);
            } else {
                Jatin_FLOAT(g_UE4 + 0x54b1580, -5.84305429e27);
            }
            break;

        case 13:
            if(Config.MemoryHacks.FlashV2){
                Jatin_FLOAT(g_UE4 + 0x5b68a7c, 23.0);
                Jatin_FLOAT(g_UE4 + 0x54d5478, 0.27500000596);
                Jatin_FLOAT(g_UE4 + 0x54b1580, 0.0);
            } else {
                Jatin_FLOAT(g_UE4 + 0x5b68a7c, 25.72529029846);
                Jatin_FLOAT(g_UE4 + 0x54d5478, 9.99999997e-7);
                Jatin_FLOAT(g_UE4 + 0x54b1580, -5.84305429e27);
            }
            break;

        case 14:
            if(Config.MemoryHacks.FlashV5){
                Jatin_FLOAT(g_UE4 + 0x5b68a7c, 21.0);
                Jatin_FLOAT(g_UE4 + 0x54d5478, 0.28000000119);
                Jatin_FLOAT(g_UE4 + 0x54b1580, 0.0);
            } else {
                Jatin_FLOAT(g_UE4 + 0x5b68a7c, 25.72529029846);
                Jatin_FLOAT(g_UE4 + 0x54d5478, 9.99999997e-7);
                Jatin_FLOAT(g_UE4 + 0x54b1580, -5.84305429e27);
            }
            break;
        case 16:
            if(Config.MemoryHacks.FlashV1){
                Jatin_FLOAT(g_UE4 + 0x5b68a7c, 21.5);
                Jatin_FLOAT(g_UE4 + 0x54d5478, 0.27500000596);
            } else {
                Jatin_FLOAT(g_UE4 + 0x5b68a7c, 25.72529029846);
                Jatin_FLOAT(g_UE4 + 0x54d5478, 9.99999997e-7);
            }
            break;
        case 15:
            if(Config.MemoryHacks.KnockSpeed){
                fValue = -2.73959308e28f;
                Tools::WriteAddr((void*)(g_UE4 + 0x12136E8), (void*)&fValue , 4);
            } else {
                fValue = -2.73959284e28f;
                Tools::WriteAddr((void*)(g_UE4 + 0x12136E8), (void*)&fValue , 4);
            }
            break;
    }

    return 0;
}


[[noreturn]] void * godThread(void *) {
    bool godview = false;
    bool godview1 = false;
    bool godview2 = false;
    bool godview3 = false;
    bool godview4 = false;
    bool godview5 = false;
	bool cartracking = false;
    while (true) {
        auto t1 = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
        auto localPlayer = g_LocalPlayer;
        auto localController = g_LocalController;

        if (localPlayer && localController) {

            if (Config.MemoryHacks.godview) {
                auto body = * (int *)((uintptr_t) localPlayer + 0x11d0);
			    auto camera = * (int *)((uintptr_t) localPlayer + 0x1324);
                USceneComponent * MeshContainer = localPlayer->MeshContainer;
                UCustomSpringArmComponent * SpringArmComp = localPlayer->SpringArmComp;
                if (Config.MemoryHacks.down) {
			    Write<float>(camera + 0x120, -288);
                Write<float>(body + 0x120, -288);
				godview = true;
                }
                if (!Config.MemoryHacks.down && godview == true) {
                Write<float>(body + 0x120, -88);
				Write<float>(camera + 0x120, -88);
				godview = false;
                }

                if (Config.MemoryHacks.right)
                {
                   Write<float>(camera + 0x11C, 370);
				Write<float>(body + 0x11C, 370);
                    godview2 = true;
                }

                if (!Config.MemoryHacks.right && godview2 == true)
                {
                    Write<float>(camera + 0x11C, 0);
				Write<float>(body + 0x11C, 0);
                    godview2 = false;

                }

                if (Config.MemoryHacks.left) {
                  Write<float>(camera + 0x11C, -370);
				Write<float>(body + 0x11C, -370);
                    godview3 = true;
                }
                if (!Config.MemoryHacks.left && godview3 == true)
                {
                   Write<float>(camera + 0x11C, 0);
				Write<float>(body + 0x11C, 0);
                    godview3 = false;

                }

                if (Config.MemoryHacks.front)
                {
                   Write<float>(camera + 0x118, 288);
				   Write<float>(body + 0x118, 288);
                    godview4 = true;

                }

                if (!Config.MemoryHacks.front  && godview4 == true)
                {
                    Write<float>(camera + 0x118, 0);
				   Write<float>(body + 0x118, 0);
                    godview4 = false;
                }

                if (Config.MemoryHacks.BEHIND)
                {
                    Write<float>(camera + 0x118, -288);
                    Write<float>(body + 0x118, -288);
//                    MeshContainer->RelativeLocation.X = -200;
//                    SpringArmComp->RelativeLocation.X = -200;
                    godview5 = true;
                }


                if (!Config.MemoryHacks.BEHIND && godview4 == true)
                {
//                    MeshContainer->RelativeLocation.X = 0;
//                    SpringArmComp->RelativeLocation.X = 0;
                    Write<float>(camera + 0x118, 0);
                    Write<float>(body + 0x118, 0);
                    godview5 = false;
                }//BEHIND



                if (Config.MemoryHacks.up) {

                    auto root = * (int *)((uintptr_t) localPlayer + 0x154) + 0x158;
                    float ground;
                    Tools::PVM_ReadAddr((void *)(root), & ground, sizeof(ground));
                    while (true) {
                        Write<float>(root, ground + 309);
                        if (!Config.MemoryHacks.up) {
                            break;
                        }
                    }
                }


            }
        }

        auto td = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() - t1;
        std::this_thread::sleep_for(std::chrono::milliseconds(std::max(std::min(0LL, SLEEP_TIME - td), SLEEP_TIME)));
    }
    return 0;
}


void *skin_thread(void *) {
    if(Config.MemoryHacks.killmessage){
        Tools::Hook((void*) (g_UE4 + 0x2aab1e0), (void*) Hook_sub_288C090, (void **) &Orig_sub_288C090);
    } else {
        Tools::Hook((void*) (g_UE4 + 0x2aab1e0), (void*) Orig_sub_288C090, (void **) &Hook_sub_288C090);
    }
    return 0;
}
void DrawTextCentered(const char *text)
{
    ImGui::Separator();
    ImGui::SetCursorPosX((ImGui::GetWindowWidth() - ImGui::CalcTextSize(text).x) / 5.f);
    ImGui::Text(text);
    ImGui::Separator();
}

// ======================================================================== //

	namespace Settings
{
    static int Tab = 1;
}

	EGLBoolean (*orig_eglSwapBuffers)(EGLDisplay dpy, EGLSurface surface);
EGLBoolean _eglSwapBuffers(EGLDisplay dpy, EGLSurface surface) {
           eglQuerySurface(dpy, surface, EGL_WIDTH, &glWidth);
            eglQuerySurface(dpy, surface, EGL_HEIGHT, &glHeight);
            if (glWidth <= 0 || glHeight <= 0)
            return orig_eglSwapBuffers(dpy, surface);
  
            if (!g_App)
            return orig_eglSwapBuffers(dpy, surface);

            screenWidth = ANativeWindow_getWidth(g_App->window);
            screenHeight = ANativeWindow_getHeight(g_App->window);
            density = AConfiguration_getDensity(g_App->config);

    if (!initImGui) {
        ImGui::CreateContext();

        ImGuiStyle *style = &ImGui::GetStyle();
             //    ImGui::StyleColorsDark(style);
        //    ImGui::StyleColorsLight(style);

               //  ImGuiStyle& style = ImGui::GetStyle();
            //    style->WindowPadding = ImVec2(15, 10);
            style->WindowRounding = 4.0f;
        //    style->FramePadding = ImVec2(4, 5);
                style->FrameBorderSize = 2.5f;
            style->FrameRounding = 4.0f;
			
	style->Colors[ImGuiCol_Text]                   = ImVec4(0.92f, 0.92f, 0.92f, 1.00f);
    style->Colors[ImGuiCol_TextDisabled]           = ImVec4(0.44f, 0.44f, 0.44f, 1.00f);
    style->Colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 1.00f);
    style->Colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    style->Colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
    style->Colors[ImGuiCol_Border]                 = ImVec4(0.51f, 0.36f, 0.15f, 1.00f);
    style->Colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    style->Colors[ImGuiCol_FrameBg]                = ImVec4(0.11f, 0.11f, 0.11f, 1.00f);
    style->Colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.51f, 0.36f, 0.15f, 1.00f);
    style->Colors[ImGuiCol_FrameBgActive]          = ImVec4(0.78f, 0.55f, 0.21f, 1.00f);
    style->Colors[ImGuiCol_TitleBg]                = ImVec4(0.51f, 0.36f, 0.15f, 1.00f);
    style->Colors[ImGuiCol_TitleBgActive]          = ImVec4(0.91f, 0.64f, 0.13f, 1.00f);
    style->Colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
    style->Colors[ImGuiCol_MenuBarBg]              = ImVec4(0.11f, 0.11f, 0.11f, 1.00f);
    style->Colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.06f, 0.06f, 0.06f, 0.53f);
    style->Colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.21f, 0.21f, 0.21f, 1.00f);
    style->Colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.47f, 0.47f, 0.47f, 1.00f);
    style->Colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.81f, 0.83f, 0.81f, 1.00f);
    style->Colors[ImGuiCol_CheckMark]              = ImVec4(0.78f, 0.55f, 0.21f, 1.00f);
    style->Colors[ImGuiCol_SliderGrab]             = ImVec4(0.91f, 0.64f, 0.13f, 1.00f);
    style->Colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.91f, 0.64f, 0.13f, 1.00f);
    style->Colors[ImGuiCol_Button]                 = ImVec4(0.51f, 0.36f, 0.15f, 1.00f);
    style->Colors[ImGuiCol_ButtonHovered]          = ImVec4(0.91f, 0.64f, 0.13f, 1.00f);
    style->Colors[ImGuiCol_ButtonActive]           = ImVec4(0.78f, 0.55f, 0.21f, 1.00f);
    style->Colors[ImGuiCol_Header]                 = ImVec4(0.51f, 0.36f, 0.15f, 1.00f);
    style->Colors[ImGuiCol_HeaderHovered]          = ImVec4(0.91f, 0.64f, 0.13f, 1.00f);
    style->Colors[ImGuiCol_HeaderActive]           = ImVec4(0.93f, 0.65f, 0.14f, 1.00f);
    style->Colors[ImGuiCol_Separator]              = ImVec4(0.21f, 0.21f, 0.21f, 1.00f);
    style->Colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.91f, 0.64f, 0.13f, 1.00f);
    style->Colors[ImGuiCol_SeparatorActive]        = ImVec4(0.78f, 0.55f, 0.21f, 1.00f);
    style->Colors[ImGuiCol_ResizeGrip]             = ImVec4(0.21f, 0.21f, 0.21f, 1.00f);
    style->Colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.91f, 0.64f, 0.13f, 1.00f);
    style->Colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.78f, 0.55f, 0.21f, 1.00f);
    style->Colors[ImGuiCol_Tab]                    = ImVec4(0.51f, 0.36f, 0.15f, 1.00f);
    style->Colors[ImGuiCol_TabHovered]             = ImVec4(0.91f, 0.64f, 0.13f, 1.00f);
    style->Colors[ImGuiCol_TabActive]              = ImVec4(0.78f, 0.55f, 0.21f, 1.00f);
    style->Colors[ImGuiCol_TabUnfocused]           = ImVec4(0.07f, 0.10f, 0.15f, 0.97f);
    style->Colors[ImGuiCol_TabUnfocusedActive]     = ImVec4(0.14f, 0.26f, 0.42f, 1.00f);
    style->Colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
    style->Colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
    style->Colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    style->Colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
    style->Colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
    style->Colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
    style->Colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    style->Colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
    style->Colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
    style->Colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);

            style->ScaleAllSizes(std::max(1.5f, density / 200.0f));
			
			
        style->ScrollbarSize /= 1;

            ImGui_ImplAndroid_Init();
            ImGui_ImplOpenGL3_Init("#version 300 es");

        ImGuiIO &io = ImGui::GetIO();
        
        static const ImWchar icons_ranges[] = { 0xf000, 0xf3ff, 0 };
        ImFontConfig icons_config;

        ImFontConfig CustomFont;
        CustomFont.FontDataOwnedByAtlas = false;

        icons_config.MergeMode = true;
        icons_config.PixelSnapH = true;
        icons_config.OversampleH = 2.5;
        icons_config.OversampleV = 2.5;

        io.Fonts->AddFontFromMemoryTTF(const_cast<std::uint8_t*>(Custom), sizeof(Custom), 21.0f, &CustomFont);
        io.Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 21.0f, &icons_config, icons_ranges);
        
        io.ConfigWindowsMoveFromTitleBarOnly = true;
        ImFontConfig cfg;
        
            memset(&Config, 0, sizeof(sConfig));

// ===============================ESPCOLOR ================================== //


                Config.ColorsESP.Line = CREATE_COLOR(255, 0, 0, 255);
        Config.ColorsESP.Box = CREATE_COLOR(255, 0, 0, 255);
        Config.ColorsESP.Name = CREATE_COLOR(255, 255, 255, 255);
        Config.ColorsESP.Skeleton = CREATE_COLOR(255, 0, 0, 255);
        Config.ColorsESP.Vehicle = CREATE_COLOR(255, 255, 255, 255);
        Config.ColorsESP.SkeletonVisible = CREATE_COLOR(0, 255, 0, 255);
	   Config.ColorsESP.Fov = CREATE_COLOR(255, 255, 255, 255);

	   Config.PlayerESP.DistanceMax = 500;
        items_data = json::parse(JSON_ITEMS);

        for (auto &i : items_data) {
            for (auto &item : i["Items"]) {
                int r, g, b;
                sscanf(item["itemTextColor"].get<std::string>().c_str(), "#%02X%02X%02X", &r, &g, &b);
                ItemColors[item["itemId"].get<int>()] = CREATE_COLOR(r, g, b, 255);
            } 
        } 
        initImGui = true;
    }

    ImGuiIO &io = ImGui::GetIO();

        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplAndroid_NewFrame(glWidth, glHeight);
        ImGui::NewFrame();

        DrawESP(ImGui::GetBackgroundDrawList());

        ImGui::SetNextWindowSize(ImVec2((float) glWidth * 0.40f, (float) glHeight * 0.65f), ImGuiCond_Once);

         if (ImGui::Begin(OBFUSCATE(ICON_FA_GAMEPAD" Robion Test | Join:@RobionSTORE | 32-Bit" ), 0, ImGuiWindowFlags_NoBringToFrontOnFocus )) {
            static bool isLogin = true;

            static std::string err;
            if (!isLogin) {
                ImGui::Text("Please Login! (Copy Key to Clipboard)");

                ImGui::PushItemWidth(-1);
                static char s[64];
                ImGui::InputText("##key", s, sizeof s);
                // auto paste
                auto key = getClipboardText();
                strncpy(s, key.c_str(), sizeof s);
                // auto login

                err = Login(s);
                if (err == "OK") {
                    isLogin = bValid && g_Auth == g_Token;
                }
                ImGui::PopItemWidth();

                ImGui::PushItemWidth(-1);
                if (ImGui::Button(" Paste Your Key  ", ImVec2(ImGui::GetContentRegionAvailWidth(), 0))) {
                    auto key = getClipboardText();
                    strncpy(s, key.c_str(), sizeof s);
                }
                ImGui::PopItemWidth();

                ImGui::PushItemWidth(-1);


                if (ImGui::Button("Login", ImVec2(ImGui::GetContentRegionAvailWidth(), 0))) {
                    err = Login(s);
                    if (err == "OK") {
                        isLogin = bValid && g_Auth == g_Token;
                    }
                }
                ImGui::PopItemWidth();

                if (!err.empty() && err != "OK") {
                    ImGui::Text("Error: %s", err.c_str());
                }

                ImGui::PopItemWidth();


		    
            } else {
				
                ImGui::Columns(2);
            ImGui::SetColumnOffset(1, 245);
            {
      

                
                static ImVec4 active = ImguiPP::to_vec4(0, 150, 255, 255);
                static ImVec4 inactive = ImguiPP::to_vec4(31, 30, 31, 255);
				
                ImGui::PushStyleColor(ImGuiCol_Button, Settings::Tab == 1 ? active : inactive);
                if (ImGui::Button(ICON_FA_USERS"Player Menu", ImVec2(230 - 15, 50)))
			
                    Settings::Tab = 1;

					
                ImGui::Spacing();
              
                ImGui::PushStyleColor(ImGuiCol_Button, Settings::Tab == 2 ? active : inactive);
                if (ImGui::Button(ICON_FA_DROPBOX"Items Menu", ImVec2(230 - 15, 50)))
                    Settings::Tab = 2;

                
				  ImGui::Spacing();
          
                ImGui::PushStyleColor(ImGuiCol_Button, Settings::Tab == 3 ? active : inactive);
                if (ImGui::Button(ICON_FA_BOMB"Aim Menu", ImVec2(230 - 15, 50)))
                    Settings::Tab = 3;
					
					  ImGui::Spacing();
               
                ImGui::PushStyleColor(ImGuiCol_Button, Settings::Tab == 4 ? active : inactive);
                if (ImGui::Button(ICON_FA_CROSSHAIRS"Kill Message ", ImVec2(230 - 15, 50)))
                    Settings::Tab = 4;

					
                ImGui::Spacing();
          
                ImGui::PushStyleColor(ImGuiCol_Button, Settings::Tab == 5 ? active : inactive);
                if (ImGui::Button(ICON_FA_DROPBOX"Memory Menu", ImVec2(230 - 15, 50)))
                    Settings::Tab = 5;

                ImGui::PopStyleColor(5);

            }
            
            
            
            
             ImGui::NextColumn();
                        // 𝐑𝐈𝐆𝐇𝐓 𝐇𝐀𝐍𝐃 𝐌𝐄𝐍𝐔

                        if (Settings::Tab == 1) {

                            ImGui::Spacing();
                            if (ImGui::BeginTable("split", 2));
                            {
                                if (ImGui::BeginTable("split", 2));
                                {
                                 ImGui::TableNextColumn();       
           //     ImGui::SetNextItemOpen(true);      
        ImGui::Checkbox("ESP Line", &Config.PlayerESP.Line);
                ImGui::TableNextColumn(); 
      ImGui::Checkbox("ESP Box", &Config.PlayerESP.Box);
                ImGui::TableNextColumn();
        ImGui::Checkbox("ESP Skeleton", &Config.PlayerESP.Skeleton);
               ImGui::TableNextColumn();
        ImGui::Checkbox("ESP Health", &Config.PlayerESP.Health);
               ImGui::TableNextColumn();
        ImGui::Checkbox("ESP Name", &Config.PlayerESP.Name);
               ImGui::TableNextColumn();
        ImGui::Checkbox("ESP Weapon", &Config.PlayerESP.Weapon);
               ImGui::TableNextColumn();
        ImGui::Checkbox("ESP Distance", &Config.PlayerESP.Distance);
              ImGui::TableNextColumn();                 
       ImGui::Checkbox("ESP TeamID", &Config.PlayerESP.TeamID);      
       ImGui::TableNextColumn();      
     /*   ImGui::Checkbox("ESP 360", &Config.PlayerESP.Alert);
             ImGui::TableNextColumn();     */      
  	   ImGui::Checkbox("Hide BOT", &Config.PlayerESP.NoBot);
	         ImGui::TableNextColumn();
	         ImGui::TableNextColumn();
             ImGui::Text("_-_OTHER ESP_-_ ");
             ImGui::TableNextColumn();
             ImGui::TableNextColumn();
       ImGui::Checkbox("ESP Vehicle", &Config.VehicleESP.ShowVehicle);
             ImGui::TableNextColumn();
       ImGui::Checkbox("ESP LootBox", &Config.PlayerESP.LootBox);
             ImGui::TableNextColumn();
       ImGui::Checkbox("ESP Grenade", &Config.PlayerESP.Grenade);    
                                    ImGui::RadioButton("Bypass", &Config.Bypass);
                                }
                                ImGui::EndTable();
                            }

                        }
                        else if (Settings::Tab == 2) {
				
                            ImGui::TextColored(ImVec4(255,255,0,255), "Item Menu;");
                            ImGui::Spacing();

                            for (auto &i : items_data) {
      if (ImGui::TreeNode(i["Category"].get<std::string>().c_str())) {
                                    ImGui::Spacing();
                                    for (auto &item : i["Items"]) {
              ImGui::Checkbox(item["itemName"].get<std::string>().c_str(),
                              (bool *) &Items[item["itemId"].get<int>()]);
                              
                        }
						}
						}
                        }
						
                        else if (Settings::Tab == 3) {
					 ImGui::TextColored(ImVec4(255,255,0,255), "AIMBOT;");	
					 ImGui::Checkbox(ICON_FA_CROSSHAIRS" ENABLE AIMBOT", &Config.AimBot.Enable);
					 ImGui::SliderFloat("Fov", &FOVSize, 0.0f, 250.0f); 
										ImGui::SameLine();
										ImGui::ColorEdit3("##FovCol", Config.ColorsESP.Fov, ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_NoInputs);
				//ImGui::SliderFloat("Recoil", &Config.AimBot.Recc, 0.0f, 2.0f);
				ImGui::SliderFloat("Target", &Config.Recc, 0.6f, 1.9f);
				ImGui::SliderFloat("Meter", &Config.Meter, 0.0f, 100.0f); 
				static const char *targets[] = {"Head", "Body"};
                ImGui::Combo("##Target", (int *) &Config.AimBot.Target, targets, 2, -1);
				static const char *triggers[] = {"None", "Shooting", "Scoping", "Both Shooting/Scoping", "Any Shooting/Scoping"};
                ImGui::Combo("##Trigger", (int *) &Config.AimBot.Trigger, triggers, 5, -1);
				
				ImGui::Checkbox("Ignore Bot", &Config.AimBot.IgnoreBot);
		
				ImGui::Checkbox("Prediction ", &Config.AimBot.Predection);		
	
                ImGui::Checkbox("Ignore Knocked", &Config.AimBot.IgnoreKnocked);
		
		        ImGui::Checkbox("Vis Check", &Config.AimBot.VisCheck);
						}

                        	else if (Settings::Tab == 4) {
                           
                              if(ImGui::Checkbox("GUN SKIN", &Config.MemoryHacks.killmessage))
                                    {   
									pthread_t t;
									pthread_create(&t, 0, skin_thread, 0);
                                    }
								    ImGui::TableNextColumn(); 
                                    ImGui::Text("X-SUIT SKIN");
                                    const char* xsuity[] = { "NO SKIN", "Blood Raven X-Suit", "Golden Pharaoh X-Suit", "Avalanche X-suit", "Irresidence X-suit", "Poseidon X-suit", "Arcane Jester X-suit", "Silvanus X-Suit"};
                                    ImGui::Combo("##xs", &xsuit, xsuity, IM_ARRAYSIZE(xsuity));
                                    ImGui::TableNextColumn();
                                    ImGui::Spacing();
									ImGui::Separator();
                                    ImGui::Text("M416 SKIN");
                                    const char* m416[] = { "NO SKIN", " Glacier - M416", "The Fool - M416","Lizard Roar - M416"," Wanderer - M416","Call of the Wild - M416", "Imperial Splendor - M416", "Silver Guru - M416", "TechnoCore - M416" };
                                    ImGui::Combo("##m4", &skinm4, m416, IM_ARRAYSIZE(m416));
                                    ImGui::TableNextColumn();
                                    ImGui::Spacing();
									ImGui::Text("AKM SKIN");
                                    const char* AKM[] = { "NO SKIN", "Sculpture - AKM", "The Seven Seas - AKM","Roaring Tiger - AKM","Glacier - AKM","Desert Fossil - AKM","Jack-o'-lantern - AKM","Ghillie Dragon - AKM", "Gold Pirate - AKM","Wandering Tyrant - AKM","Star Admiral - AKM","Hellfire - AKM"};
                                    ImGui::Combo("##AKM", &skinakm, AKM, IM_ARRAYSIZE(AKM));
                                    ImGui::TableNextColumn();
                                    ImGui::Spacing();
									ImGui::Text("SCAR-L SKIN");
                                    const char* SCAR[] = { "NO SKIN", "Water Blaster - SCAR-L", "Enchanted Pumpkin - SCAR-L","Operation Tomorrow - SCAR-L","Drop the Bass - SCAR-L ","Hextech Crystal - SCAR-L","THORN OF MALICE - SCAR-L"};
                                    ImGui::Combo("##SCAR-L", &skinscar, SCAR, IM_ARRAYSIZE(SCAR));
                                    ImGui::TableNextColumn();
                                    ImGui::Spacing();
									ImGui::Text("M762 SKIN");
                                    const char* M7[] =  {"NO SKIN", "8-bit Unicorn - M762", "GACKT MOONSAGA-M762","Lotus Fury - M762",  "Messi Football Icon M762","Concerto of Love - M762","StarCore-M762","Stray Rebellion - M762"};
                                    ImGui::Combo("##M762", &skinm7, M7, IM_ARRAYSIZE(M7));
								    ImGui::TableNextColumn();
									ImGui::Spacing();                                   
                                    ImGui::Text("M249 SKIN");
                                    const char* m2499[] =  {"NO SKIN", "Party Parcel - M249", "Winter Queen M249 V","Mondrop Eterna - M249"};
                                    ImGui::Combo("##M249", &skinm249, m2499, IM_ARRAYSIZE(m2499));
									ImGui::TableNextColumn();
									ImGui::Spacing();
									ImGui::Text("AWM SKIN");
                                    const char* AWMM[] =  {"NO SKIN", "Mauve Avenger - AWM", "Field Commander - AWM","Godzilla - AWM","Flame Wave - AWM"};
                                    ImGui::Combo("##AWM", &skinawm, AWMM, IM_ARRAYSIZE(AWMM));
									ImGui::TableNextColumn();
                                    ImGui::Spacing();
                                    ImGui::Text("KAR98K SKIN");
                                    const char* KARR[] =  {"NO SKIN", "Terror Fang - Kar98K", "Kukulkan Fury - Kar98K","Night of Rock - Kar98K","Moonlit Grace - Kar98K"};
                                    ImGui::Combo("##KAR98K", &skinkar, KARR, IM_ARRAYSIZE(KARR));
                                    ImGui::TableNextColumn();
                                    ImGui::Spacing();
                                    ImGui::Text("M24 SKIN");
                                    const char* m244[] =  {"NO SKIN", "The Seven Seas - M24", "Pharaoh's Might - M24","Lady Butterfly - M24","Killer Tune - M24","Circle of Life - M24"};
									ImGui::Combo("##M24", &skinm24, m244, IM_ARRAYSIZE(m244));
									ImGui::TableNextColumn();
                                    ImGui::Spacing();
                                    ImGui::Text("UZI SKIN");
                                    const char* UZII[] = { "NO SKIN", "Savagery - UZI", "Ethereal Emblem - UZI","Romantic Moments - UZI","Shimmer Power - UZI"};
                                    ImGui::Combo("##UZI", &skinuzi, UZII, IM_ARRAYSIZE(UZII));
                                    ImGui::TableNextColumn();
                                    ImGui::Spacing();
                                    ImGui::Text("UMP SKIN");
                                    const char* UMPP[] = { "NO SKIN", "Dragonfire - UMP45", "EMP - UMP45","Outlawed Fantasy - UMP45","Platinum Ripper - UMP45","Anniversary - UMP45","8 Bit Blast - UMP45"};
                                    ImGui::Combo("##UMP", &skinump45, UMPP, IM_ARRAYSIZE(UMPP));
									ImGui::TableNextColumn();
                                    ImGui::Spacing();								
                                    ImGui::Text("AUG SKIN");
                                    const char* AUGG[] =  {"NO SKIN", "Wandering Circus - AUG"};
                                    ImGui::Combo("##AUG", &skinaug, AUGG, IM_ARRAYSIZE(AUGG));
                                    ImGui::TableNextColumn();
                                    ImGui::Spacing();
                                    ImGui::Text("GROZA SKIN");
                                    const char* GROZZA[] =  {"NO SKIN", "Forest Raider - GROZA", "Styx - Groza","Eventide Aria - GROZA","Ryomen Sukuna - GROZA"};
                                    ImGui::Combo("##GROZA", &skingroza, GROZZA, IM_ARRAYSIZE(GROZZA));
									ImGui::TableNextColumn();
                                    ImGui::Spacing();									                                   
                                    ImGui::Text("DP SKIN");
                                    const char* DPP[] =  {"NO SKIN", "Enigmatic Killer - DP28", "Gilded Jade Dragon - DP28"};
                                    ImGui::Combo("##DP", &skindp28, DPP, IM_ARRAYSIZE(DPP));
                                    ImGui::TableNextColumn();
                                    ImGui::Spacing();
                                    ImGui::Text("MK14 SKIN");
                                    const char* MK144[] =  {"NO SKIN", "Gilded Galaxy - MK14"};
                                    ImGui::Combo("##MK14", &skinmk14, MK144, IM_ARRAYSIZE(MK144));
									ImGui::TableNextColumn();
                                    ImGui::Spacing();
                                    ImGui::Text("M16A4 SKIN");
                                    const char* M16A44[] =  {"NO SKIN", "Blood & Bones - M16A4", "Aurora Pulse - M16A4","Radiant Edge - M16A4","Skeletal Core - M16A4"};
                                    ImGui::Combo("##M16A4", &skinm16a4, M16A44, IM_ARRAYSIZE(M16A44));
									ImGui::TableNextColumn();
									ImGui::Spacing();
                                    ImGui::Text("BIZON SKIN");
                                    const char* BIZZON[] =  {"NO SKIN", "Blazing Chameleon - PP-19 Bizon", "Skullcrusher - PP-19 Bizon"};
                                    ImGui::Combo("##BIZON", &skinbizon, BIZZON, IM_ARRAYSIZE(BIZZON));
                                    ImGui::TableNextColumn();
                                    ImGui::Spacing();
                                    ImGui::Text("VECTOR SKIN");
                                    const char* VECTORR[] = {"NO SKIN", "Blood Tooth - Vector", "Midnight Rose - Vector","Cute Baddie - Vector","Ultimate Predator - Vector","Gilded Reaper - Vector"};
                                    ImGui::Combo("##VECTOR", &skinvector, VECTORR, IM_ARRAYSIZE(VECTORR));
									ImGui::TableNextColumn();
									}
	
          
							
                       
	                         else if (Settings::Tab == 5) {
                             ImGui::Text("Memory Menu");
                             ImGui::TableNextColumn();
					ImGui::Checkbox("X Effect", &Config.ESPMenu.HitEffect);
                    ImGui::TableNextColumn();
			    }       
		     
            }
        }
		
		


		
        ImGui::End();
        ImGui::Render();


        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

        return orig_eglSwapBuffers(dpy, surface);
    }

int32_t (*orig_onInputEvent)(struct android_app *app, AInputEvent *inputEvent);

int32_t onInputEvent(struct android_app *app, AInputEvent *inputEvent) {
    if (initImGui) {
        ImGui_ImplAndroid_HandleInputEvent(inputEvent, {(float) screenWidth / (float) glWidth, (float) screenHeight / (float) glHeight});
    }
    return orig_onInputEvent(app, inputEvent);
}

[[noreturn]] void *Memory_thread(void *) {
    while (true) {
        auto t1 = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();

                      
         /*   if (Config.ESPMenu.Recoil || Config.ESPMenu.Shake || Config.ESPMenu.Instant) {
                auto WeaponManagerComponent = g_LocalPlayer->WeaponManagerComponent;
                if (WeaponManagerComponent) {
                    auto Slot = WeaponManagerComponent->GetCurrentUsingPropSlot();
                    if ((int) Slot.GetValue() >= 1 && (int) Slot.GetValue() <= 3) {
                        auto CurrentWeaponReplicated = (ASTExtraShootWeapon *) WeaponManagerComponent->CurrentWeaponReplicated;
                        if (CurrentWeaponReplicated) {
                            auto ShootWeaponEntityComp = CurrentWeaponReplicated->ShootWeaponEntityComp;
                            auto ShootWeaponEffectComp = CurrentWeaponReplicated->ShootWeaponEffectComp;
                            if (ShootWeaponEntityComp && ShootWeaponEffectComp) {
                                if (Config.ESPMenu.Recoil) {
                                    ShootWeaponEntityComp->AccessoriesVRecoilFactor = 0.0f;
                                    ShootWeaponEntityComp->AccessoriesHRecoilFactor = 0.0f;
                                    ShootWeaponEntityComp->AccessoriesRecoveryFactor = 0.0f;

                                    ShootWeaponEntityComp->RecoilKickADS = 0.0f;
                                }

                                if (Config.ESPMenu.Shake) {
                                    ShootWeaponEffectComp->CameraShakeInnerRadius = 0.0f;
                                    ShootWeaponEffectComp->CameraShakeOuterRadius = 0.0f;
                                    ShootWeaponEffectComp->CameraShakFalloff = 0.0f;
                                }
								
	
                                if (Config.ESPMenu.Instant) {
                                    ShootWeaponEntityComp->GameDeviationFactor = 0.0f;
                                }

                                if (Config.ESPMenu.HitEffect) {
                                    ShootWeaponEntityComp->ExtraHitPerformScale = 200.0f;
								
								}
                            }}
                        }
                    }
                }*/
                

        auto td = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() - t1;
        std::this_thread::sleep_for(std::chrono::milliseconds(std::max(std::min(0LL, SLEEP_TIME - td), SLEEP_TIME)));
    }
    return 0;
}

#define SLEEP_TIME 1000LL / 60LL
[[noreturn]] void *maps_thread(void *) {
    while (true) {
        auto t1 = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();

        std::vector<sRegion> tmp;
        char line[512];
        FILE *f = fopen("/proc/self/maps", "r");
        if (f) {
            while (fgets(line, sizeof line, f)) {
                uintptr_t start, end;
                char tmpProt[16];
                if (sscanf(line, "%" PRIXPTR "-%" PRIXPTR " %16s %*s %*s %*s %*s", &start, &end, tmpProt) > 0) {
                    if (tmpProt[0] != 'r') {
                        tmp.push_back({start, end});
                    }
                }
            }
            fclose(f);
        }

        auto td = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() - t1;
        std::this_thread::sleep_for(std::chrono::milliseconds(std::max(std::min(0LL, SLEEP_TIME - td), SLEEP_TIME)));
    }
}
    

void *main_thread(void *) {
    UE4 = Tools::GetBaseAddress("libUE4.so");
    g_UE4 = Tools::GetBaseAddress("libUE4.so");
    Anogs = Tools::GetBaseAddress("libanogs.so");
    gcloud = Tools::GetBaseAddress("libgcloud.so");
    TDataMaster = Tools::GetBaseAddress("libTDataMaster.so");
	


    while (!UE4) {
        UE4 = Tools::GetBaseAddress("libUE4.so");
        sleep(1);
    }
    
    while (!g_UE4) {
        g_UE4 = Tools::GetBaseAddress("libUE4.so");
        sleep(1);
    }

    while (!Anogs) {
        Anogs = Tools::GetBaseAddress("libanogs.so");
        sleep(1);
    }
    
    while (!gcloud) {
        gcloud = Tools::GetBaseAddress("libgcloud.so");
        sleep(1);
    }
    
    
	TDataMaster = Tools::GetBaseAddress("libTDataMaster.so");
	while (!TDataMaster) {
        TDataMaster = Tools::GetBaseAddress("libTDataMaster.so");
        sleep(1);
    }
        
    while (!g_App) {
        g_App = *(android_app **) (g_UE4 + GNativeAndroidApp_Offset);
        sleep(1);
    }
	      
    FName::GNames = GetGNames();
    while (!FName::GNames) {
        FName::GNames = GetGNames();
        sleep(1);
    }
    UObject::GUObjectArray = (FUObjectArray *) (g_UE4 + GUObject_Offset);

    orig_onInputEvent = decltype(orig_onInputEvent)(g_App->onInputEvent);
    g_App->onInputEvent = onInputEvent;

    Tools::Hook((void *) DobbySymbolResolver(OBFUSCATE("/system/lib/libEGL.so"), OBFUSCATE("eglSwapBuffers")), (void *) _eglSwapBuffers, (void **) &orig_eglSwapBuffers);
    
	items_data = json::parse(JSON_ITEMS);
    pthread_t t;
    pthread_create(&t, 0, maps_thread, 0);

    return 0;
}
__attribute__((constructor)) void _init() {
    pthread_t t;
    pthread_create(&t, 0, Memory_thread, 0);
    pthread_create(&t, 0, main_thread, 0);
}
